ARM GAS  /tmp/cc1kQXNP.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"uavcan.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.shouldAcceptTransfer,"ax",%progbits
  16              		.align	1
  17              		.global	shouldAcceptTransfer
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	shouldAcceptTransfer:
  24              	.LFB67:
  25              		.file 1 "Src/uavcan.c"
   1:Src/uavcan.c  **** #include <stdio.h>
   2:Src/uavcan.c  **** #include <stdlib.h>
   3:Src/uavcan.c  **** #include "canard.h"
   4:Src/uavcan.c  **** #include "canard_stm32.h"
   5:Src/uavcan.c  **** #include "uavcan.h"
   6:Src/uavcan.c  **** #include "stm32f1xx_hal.h"
   7:Src/uavcan.c  **** #include "main.h"
   8:Src/uavcan.c  **** #include "tim.h"
   9:Src/uavcan.c  **** #include "usart.h"
  10:Src/uavcan.c  **** #include "internalflash.h"
  11:Src/uavcan.c  **** #include "gpio.h"
  12:Src/uavcan.c  **** 
  13:Src/uavcan.c  **** #define CANARD_SPIN_PERIOD      500
  14:Src/uavcan.c  **** #define PUBLISHER_PERIOD_mS     100
  15:Src/uavcan.c  **** #define SIGNALTEST_PERIOD_mS    1000
  16:Src/uavcan.c  **** #define FLASH_SAVE_ADDR         0x800F000
  17:Src/uavcan.c  **** 
  18:Src/uavcan.c  **** bool rawcommandTag=false;
  19:Src/uavcan.c  **** uint8_t nodeID=10;
  20:Src/uavcan.c  **** uint8_t LedStatus;
  21:Src/uavcan.c  **** uint8_t OutIndex;
  22:Src/uavcan.c  **** uint8_t g_canard_memory_pool[1024]; //Arena for memory allocation, used by the library
  23:Src/uavcan.c  **** uint16_t rawcommandTransfer=0;
  24:Src/uavcan.c  **** 
  25:Src/uavcan.c  **** uint16_t FlashData[4]; //flash data address/
  26:Src/uavcan.c  **** uint32_t FlashAddress=FLASH_SAVE_ADDR;    
  27:Src/uavcan.c  **** uint32_t g_uptime = 0;         
  28:Src/uavcan.c  **** static CanardInstance g_canard;//The library instance
  29:Src/uavcan.c  **** param_t parameters[] = 
  30:Src/uavcan.c  **** {
  31:Src/uavcan.c  ****     /* name      value  min max defavl*/
  32:Src/uavcan.c  ****     {"NodeID",      0,  0,  100,   0},
  33:Src/uavcan.c  ****     {"StatusRate",  0,  5,  100,  10},
ARM GAS  /tmp/cc1kQXNP.s 			page 2


  34:Src/uavcan.c  ****     {"OutIndex",    0,  0,  20,    0},
  35:Src/uavcan.c  ****     {"PWMFrequency",0,  490,1000,  0},
  36:Src/uavcan.c  ****     
  37:Src/uavcan.c  **** };
  38:Src/uavcan.c  **** 
  39:Src/uavcan.c  **** bool shouldAcceptTransfer(const CanardInstance* ins,
  40:Src/uavcan.c  ****                           uint64_t* out_data_type_signature,
  41:Src/uavcan.c  ****                           uint16_t data_type_id,
  42:Src/uavcan.c  ****                           CanardTransferType transfer_type,
  43:Src/uavcan.c  ****                           uint8_t source_node_id)
  44:Src/uavcan.c  **** {
  26              		.loc 1 44 0
  27              		.cfi_startproc
  28              		@ args = 4, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
  45:Src/uavcan.c  ****     if ((transfer_type == CanardTransferTypeRequest) &&(data_type_id == UAVCAN_GET_NODE_INFO_DATA_T
  32              		.loc 1 45 0
  33 0000 012B     		cmp	r3, #1
  34 0002 07D0     		beq	.L6
  35              	.L2:
  46:Src/uavcan.c  ****     {
  47:Src/uavcan.c  ****         *out_data_type_signature = UAVCAN_GET_NODE_INFO_DATA_TYPE_SIGNATURE;
  48:Src/uavcan.c  ****         return true;
  49:Src/uavcan.c  ****     }
  50:Src/uavcan.c  ****     if(data_type_id == UAVCAN_EQUIPMENT_ESC_RAWCOMMAND_ID)
  36              		.loc 1 50 0
  37 0004 40F20643 		movw	r3, #1030
  38              	.LVL1:
  39 0008 9A42     		cmp	r2, r3
  40 000a 0CD0     		beq	.L7
  51:Src/uavcan.c  ****     {
  52:Src/uavcan.c  ****         *out_data_type_signature = UAVCAN_EQUIPMENT_ESC_RAWCOMMAND_SIGNATURE;
  53:Src/uavcan.c  ****         return true;
  54:Src/uavcan.c  ****     }
  55:Src/uavcan.c  ****     if(data_type_id == UAVCAN_PROTOCOL_PARAM_GETSET_ID)
  41              		.loc 1 55 0
  42 000c 0B2A     		cmp	r2, #11
  43 000e 11D0     		beq	.L8
  56:Src/uavcan.c  ****     {
  57:Src/uavcan.c  ****         *out_data_type_signature = UAVCAN_PROTOCOL_PARAM_GETSET_SIGNATURE;
  58:Src/uavcan.c  ****         return true;
  59:Src/uavcan.c  ****     }
  60:Src/uavcan.c  ****     return false;
  44              		.loc 1 60 0
  45 0010 0020     		movs	r0, #0
  46              	.LVL2:
  61:Src/uavcan.c  **** }
  47              		.loc 1 61 0
  48 0012 7047     		bx	lr
  49              	.LVL3:
  50              	.L6:
  45:Src/uavcan.c  ****     {
  51              		.loc 1 45 0 discriminator 1
  52 0014 012A     		cmp	r2, #1
  53 0016 F5D1     		bne	.L2
ARM GAS  /tmp/cc1kQXNP.s 			page 3


  47:Src/uavcan.c  ****         return true;
  54              		.loc 1 47 0
  55 0018 0BA3     		adr	r3, .L9
  56 001a D3E90023 		ldrd	r2, [r3]
  57              	.LVL4:
  58 001e C1E90023 		strd	r2, [r1]
  48:Src/uavcan.c  ****     }
  59              		.loc 1 48 0
  60 0022 0120     		movs	r0, #1
  61              	.LVL5:
  62 0024 7047     		bx	lr
  63              	.LVL6:
  64              	.L7:
  52:Src/uavcan.c  ****         return true;
  65              		.loc 1 52 0
  66 0026 0AA3     		adr	r3, .L9+8
  67 0028 D3E90023 		ldrd	r2, [r3]
  68              	.LVL7:
  69 002c C1E90023 		strd	r2, [r1]
  53:Src/uavcan.c  ****     }
  70              		.loc 1 53 0
  71 0030 0120     		movs	r0, #1
  72              	.LVL8:
  73 0032 7047     		bx	lr
  74              	.LVL9:
  75              	.L8:
  57:Src/uavcan.c  ****         return true;
  76              		.loc 1 57 0
  77 0034 08A3     		adr	r3, .L9+16
  78 0036 D3E90023 		ldrd	r2, [r3]
  79              	.LVL10:
  80 003a C1E90023 		strd	r2, [r1]
  58:Src/uavcan.c  ****     }
  81              		.loc 1 58 0
  82 003e 0120     		movs	r0, #1
  83              	.LVL11:
  84 0040 7047     		bx	lr
  85              	.L10:
  86 0042 00BFAFF3 		.align	3
  86      0080
  87              	.L9:
  88 0048 9E6AC421 		.word	566520478
  89 004c 818A46EE 		.word	-297366911
  90 0050 1D95ECD7 		.word	-672361187
  91 0054 875C7F21 		.word	561994887
  92 0058 D5A4D139 		.word	970040533
  93 005c F922B6A7 		.word	-1481235719
  94              		.cfi_endproc
  95              	.LFE67:
  97              		.section	.text.sendCanard,"ax",%progbits
  98              		.align	1
  99              		.global	sendCanard
 100              		.syntax unified
 101              		.thumb
 102              		.thumb_func
 103              		.fpu softvfp
 105              	sendCanard:
ARM GAS  /tmp/cc1kQXNP.s 			page 4


 106              	.LFB71:
  62:Src/uavcan.c  **** 
  63:Src/uavcan.c  **** void onTransferReceived(CanardInstance* ins, CanardRxTransfer* transfer)
  64:Src/uavcan.c  **** {
  65:Src/uavcan.c  ****     if ((transfer->transfer_type == CanardTransferTypeRequest) && (transfer->data_type_id == UAVCAN
  66:Src/uavcan.c  ****     {
  67:Src/uavcan.c  ****         getNodeInfoHandleCanard(transfer);
  68:Src/uavcan.c  ****     } 
  69:Src/uavcan.c  ****     if (transfer->data_type_id == UAVCAN_EQUIPMENT_ESC_RAWCOMMAND_ID)
  70:Src/uavcan.c  ****     {
  71:Src/uavcan.c  ****         rawcmdHandleCanard(transfer);
  72:Src/uavcan.c  ****     }
  73:Src/uavcan.c  ****     if (transfer->data_type_id == UAVCAN_PROTOCOL_PARAM_GETSET_ID)
  74:Src/uavcan.c  ****     {
  75:Src/uavcan.c  ****         getsetHandleCanard(transfer);
  76:Src/uavcan.c  ****     }
  77:Src/uavcan.c  **** 
  78:Src/uavcan.c  **** }
  79:Src/uavcan.c  **** 
  80:Src/uavcan.c  **** void getNodeInfoHandleCanard(CanardRxTransfer* transfer)
  81:Src/uavcan.c  **** {
  82:Src/uavcan.c  ****     uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE];
  83:Src/uavcan.c  ****     memset(buffer,0,UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
  84:Src/uavcan.c  ****     uint16_t len = makeNodeInfoMessage(buffer);
  85:Src/uavcan.c  ****     int result = canardRequestOrRespond(&g_canard,
  86:Src/uavcan.c  ****                                         transfer->source_node_id,
  87:Src/uavcan.c  ****                                         UAVCAN_GET_NODE_INFO_DATA_TYPE_SIGNATURE,
  88:Src/uavcan.c  ****                                         UAVCAN_GET_NODE_INFO_DATA_TYPE_ID,
  89:Src/uavcan.c  ****                                         &transfer->transfer_id,
  90:Src/uavcan.c  ****                                         transfer->priority,
  91:Src/uavcan.c  ****                                         CanardResponse,
  92:Src/uavcan.c  ****                                         &buffer[0],
  93:Src/uavcan.c  ****                                         (uint16_t)len);
  94:Src/uavcan.c  **** }
  95:Src/uavcan.c  **** 
  96:Src/uavcan.c  **** void uavcanInit(void)
  97:Src/uavcan.c  **** {
  98:Src/uavcan.c  ****     parametersLoad();
  99:Src/uavcan.c  ****     parameterCheck();
 100:Src/uavcan.c  ****     nodeID=parameters[0].val;
 101:Src/uavcan.c  ****     CanardSTM32CANTimings timings;
 102:Src/uavcan.c  ****     int result = canardSTM32ComputeCANTimings(HAL_RCC_GetPCLK1Freq(), 1000000, &timings);
 103:Src/uavcan.c  ****     if (result)
 104:Src/uavcan.c  ****     {
 105:Src/uavcan.c  ****         __ASM volatile("BKPT #01");
 106:Src/uavcan.c  ****     }
 107:Src/uavcan.c  ****     result = canardSTM32Init(&timings, CanardSTM32IfaceModeNormal);
 108:Src/uavcan.c  ****     if (result)
 109:Src/uavcan.c  ****     {
 110:Src/uavcan.c  ****         __ASM volatile("BKPT #01");
 111:Src/uavcan.c  ****     }
 112:Src/uavcan.c  ****  
 113:Src/uavcan.c  ****     canardInit(&g_canard,                         // Uninitialized library instance
 114:Src/uavcan.c  ****                g_canard_memory_pool,              // Raw memory chunk used for dynamic allocation
 115:Src/uavcan.c  ****                sizeof(g_canard_memory_pool),      // Size of the above, in bytes
 116:Src/uavcan.c  ****                onTransferReceived,                // Callback, see CanardOnTransferReception
 117:Src/uavcan.c  ****                shouldAcceptTransfer,              // Callback, see CanardShouldAcceptTransfer
ARM GAS  /tmp/cc1kQXNP.s 			page 5


 118:Src/uavcan.c  ****                NULL);
 119:Src/uavcan.c  ****                
 120:Src/uavcan.c  ****     canardSetLocalNodeID(&g_canard,nodeID);
 121:Src/uavcan.c  ****     HAL_GPIO_WritePin(LedPort,LedRed,LedOff);
 122:Src/uavcan.c  ****  
 123:Src/uavcan.c  ****        
 124:Src/uavcan.c  **** }
 125:Src/uavcan.c  **** 
 126:Src/uavcan.c  **** void sendCanard(void)
 127:Src/uavcan.c  **** {
 107              		.loc 1 127 0
 108              		.cfi_startproc
 109              		@ args = 0, pretend = 0, frame = 0
 110              		@ frame_needed = 0, uses_anonymous_args = 0
 111 0000 08B5     		push	{r3, lr}
 112              	.LCFI0:
 113              		.cfi_def_cfa_offset 8
 114              		.cfi_offset 3, -8
 115              		.cfi_offset 14, -4
 128:Src/uavcan.c  ****   const CanardCANFrame* txf = canardPeekTxQueue(&g_canard); 
 116              		.loc 1 128 0
 117 0002 0A48     		ldr	r0, .L19
 118 0004 FFF7FEFF 		bl	canardPeekTxQueue
 119              	.LVL12:
 129:Src/uavcan.c  ****   while(txf)
 120              		.loc 1 129 0
 121 0008 04E0     		b	.L12
 122              	.LVL13:
 123              	.L18:
 124              	.LBB5:
 130:Src/uavcan.c  ****     {
 131:Src/uavcan.c  ****         const int tx_res = canardSTM32Transmit(txf);
 132:Src/uavcan.c  ****         if (tx_res < 0)                  // Failure - drop the frame and report
 133:Src/uavcan.c  ****         {
 134:Src/uavcan.c  ****             __ASM volatile("BKPT #01");  // TODO: handle the error properly
 125              		.loc 1 134 0
 126              		.syntax unified
 127              	@ 134 "Src/uavcan.c" 1
 128 000a 01BE     		BKPT #01
 129              	@ 0 "" 2
 130              		.thumb
 131              		.syntax unified
 132 000c 07E0     		b	.L13
 133              	.LVL14:
 134              	.L14:
 135:Src/uavcan.c  ****         }
 136:Src/uavcan.c  ****         if(tx_res > 0)
 137:Src/uavcan.c  ****         {
 138:Src/uavcan.c  ****             canardPopTxQueue(&g_canard);
 139:Src/uavcan.c  ****         }
 140:Src/uavcan.c  ****         txf = canardPeekTxQueue(&g_canard); 
 135              		.loc 1 140 0
 136 000e 0748     		ldr	r0, .L19
 137 0010 FFF7FEFF 		bl	canardPeekTxQueue
 138              	.LVL15:
 139              	.L12:
 140              	.LBE5:
ARM GAS  /tmp/cc1kQXNP.s 			page 6


 129:Src/uavcan.c  ****     {
 141              		.loc 1 129 0
 142 0014 48B1     		cbz	r0, .L17
 143              	.LBB6:
 131:Src/uavcan.c  ****         if (tx_res < 0)                  // Failure - drop the frame and report
 144              		.loc 1 131 0
 145 0016 FFF7FEFF 		bl	canardSTM32Transmit
 146              	.LVL16:
 132:Src/uavcan.c  ****         {
 147              		.loc 1 132 0
 148 001a 0028     		cmp	r0, #0
 149 001c F5DB     		blt	.L18
 150              	.L13:
 136:Src/uavcan.c  ****         {
 151              		.loc 1 136 0
 152 001e 0028     		cmp	r0, #0
 153 0020 F5DD     		ble	.L14
 138:Src/uavcan.c  ****         }
 154              		.loc 1 138 0
 155 0022 0248     		ldr	r0, .L19
 156              	.LVL17:
 157 0024 FFF7FEFF 		bl	canardPopTxQueue
 158              	.LVL18:
 159 0028 F1E7     		b	.L14
 160              	.LVL19:
 161              	.L17:
 162              	.LBE6:
 141:Src/uavcan.c  ****     }
 142:Src/uavcan.c  **** }
 163              		.loc 1 142 0
 164 002a 08BD     		pop	{r3, pc}
 165              	.L20:
 166              		.align	2
 167              	.L19:
 168 002c 00000000 		.word	.LANCHOR0
 169              		.cfi_endproc
 170              	.LFE71:
 172              		.section	.text.publishCanard,"ax",%progbits
 173              		.align	1
 174              		.global	publishCanard
 175              		.syntax unified
 176              		.thumb
 177              		.thumb_func
 178              		.fpu softvfp
 180              	publishCanard:
 181              	.LFB74:
 143:Src/uavcan.c  **** 
 144:Src/uavcan.c  **** void receiveCanard(void)
 145:Src/uavcan.c  **** {
 146:Src/uavcan.c  ****     CanardCANFrame rx_frame;
 147:Src/uavcan.c  ****     int res = canardSTM32Receive(&rx_frame);
 148:Src/uavcan.c  ****     if(res)
 149:Src/uavcan.c  ****     {
 150:Src/uavcan.c  ****         canardHandleRxFrame(&g_canard, &rx_frame, HAL_GetTick() * 1000);
 151:Src/uavcan.c  ****     }    
 152:Src/uavcan.c  ****     signalTag(rawcommandTransfer);
 153:Src/uavcan.c  **** 
ARM GAS  /tmp/cc1kQXNP.s 			page 7


 154:Src/uavcan.c  **** }
 155:Src/uavcan.c  **** 
 156:Src/uavcan.c  **** void spinCanard(void)
 157:Src/uavcan.c  **** {  
 158:Src/uavcan.c  ****     static uint32_t spin_time = 0;
 159:Src/uavcan.c  ****     if(HAL_GetTick() < spin_time + CANARD_SPIN_PERIOD) return;  // rate limiting
 160:Src/uavcan.c  ****     spin_time = HAL_GetTick();
 161:Src/uavcan.c  ****     uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE];    
 162:Src/uavcan.c  ****     static uint8_t transfer_id = 0;                           // This variable MUST BE STATIC; refe
 163:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);  
 164:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 165:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
 166:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_ID,
 167:Src/uavcan.c  ****                     &transfer_id,
 168:Src/uavcan.c  ****                     CANARD_TRANSFER_PRIORITY_LOW,
 169:Src/uavcan.c  ****                     buffer, 
 170:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_MESSAGE_SIZE);                         //some indication
 171:Src/uavcan.c  ****     
 172:Src/uavcan.c  **** }
 173:Src/uavcan.c  **** 
 174:Src/uavcan.c  **** void publishCanard(void)
 175:Src/uavcan.c  **** {  
 182              		.loc 1 175 0
 183              		.cfi_startproc
 184              		@ args = 0, pretend = 0, frame = 0
 185              		@ frame_needed = 0, uses_anonymous_args = 0
 186 0000 08B5     		push	{r3, lr}
 187              	.LCFI1:
 188              		.cfi_def_cfa_offset 8
 189              		.cfi_offset 3, -8
 190              		.cfi_offset 14, -4
 176:Src/uavcan.c  ****     static uint32_t publish_time = 0;
 177:Src/uavcan.c  ****     if(HAL_GetTick() < publish_time + PUBLISHER_PERIOD_mS) {return;} // rate limiting
 191              		.loc 1 177 0
 192 0002 FFF7FEFF 		bl	HAL_GetTick
 193              	.LVL20:
 194 0006 054B     		ldr	r3, .L25
 195 0008 1B68     		ldr	r3, [r3]
 196 000a 6433     		adds	r3, r3, #100
 197 000c 9842     		cmp	r0, r3
 198 000e 00D2     		bcs	.L24
 199              	.L21:
 178:Src/uavcan.c  ****     publish_time = HAL_GetTick();
 179:Src/uavcan.c  **** }
 200              		.loc 1 179 0
 201 0010 08BD     		pop	{r3, pc}
 202              	.L24:
 178:Src/uavcan.c  ****     publish_time = HAL_GetTick();
 203              		.loc 1 178 0
 204 0012 FFF7FEFF 		bl	HAL_GetTick
 205              	.LVL21:
 206 0016 014B     		ldr	r3, .L25
 207 0018 1860     		str	r0, [r3]
 208 001a F9E7     		b	.L21
 209              	.L26:
 210              		.align	2
 211              	.L25:
ARM GAS  /tmp/cc1kQXNP.s 			page 8


 212 001c 00000000 		.word	.LANCHOR1
 213              		.cfi_endproc
 214              	.LFE74:
 216              		.section	.text.makeNodeStatusMessage,"ax",%progbits
 217              		.align	1
 218              		.global	makeNodeStatusMessage
 219              		.syntax unified
 220              		.thumb
 221              		.thumb_func
 222              		.fpu softvfp
 224              	makeNodeStatusMessage:
 225              	.LFB75:
 180:Src/uavcan.c  **** 
 181:Src/uavcan.c  **** void makeNodeStatusMessage(uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE])
 182:Src/uavcan.c  **** {
 226              		.loc 1 182 0
 227              		.cfi_startproc
 228              		@ args = 0, pretend = 0, frame = 8
 229              		@ frame_needed = 0, uses_anonymous_args = 0
 230              	.LVL22:
 231 0000 30B5     		push	{r4, r5, lr}
 232              	.LCFI2:
 233              		.cfi_def_cfa_offset 12
 234              		.cfi_offset 4, -12
 235              		.cfi_offset 5, -8
 236              		.cfi_offset 14, -4
 237 0002 83B0     		sub	sp, sp, #12
 238              	.LCFI3:
 239              		.cfi_def_cfa_offset 24
 240 0004 0446     		mov	r4, r0
 183:Src/uavcan.c  ****     uint8_t node_health = UAVCAN_NODE_HEALTH_OK;
 241              		.loc 1 183 0
 242 0006 0025     		movs	r5, #0
 243 0008 8DF80750 		strb	r5, [sp, #7]
 184:Src/uavcan.c  ****     uint8_t node_mode   = UAVCAN_NODE_MODE_OPERATIONAL;
 244              		.loc 1 184 0
 245 000c 8DF80650 		strb	r5, [sp, #6]
 185:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_NODE_STATUS_MESSAGE_SIZE);
 246              		.loc 1 185 0
 247 0010 0560     		str	r5, [r0]	@ unaligned
 248 0012 C0F80350 		str	r5, [r0, #3]	@ unaligned
 186:Src/uavcan.c  ****     uint32_t uptime_sec = (HAL_GetTick() / 1000);
 249              		.loc 1 186 0
 250 0016 FFF7FEFF 		bl	HAL_GetTick
 251              	.LVL23:
 252 001a 0E4B     		ldr	r3, .L29
 253 001c A3FB0030 		umull	r3, r0, r3, r0
 254 0020 8009     		lsrs	r0, r0, #6
 255 0022 02AB     		add	r3, sp, #8
 256 0024 43F8080D 		str	r0, [r3, #-8]!
 187:Src/uavcan.c  ****     canardEncodeScalar(buffer,  0, 32, &uptime_sec);
 257              		.loc 1 187 0
 258 0028 2022     		movs	r2, #32
 259 002a 2946     		mov	r1, r5
 260 002c 2046     		mov	r0, r4
 261 002e FFF7FEFF 		bl	canardEncodeScalar
 262              	.LVL24:
ARM GAS  /tmp/cc1kQXNP.s 			page 9


 188:Src/uavcan.c  ****     canardEncodeScalar(buffer, 32,  2, &node_health);
 263              		.loc 1 188 0
 264 0032 0DF10703 		add	r3, sp, #7
 265 0036 0222     		movs	r2, #2
 266 0038 2021     		movs	r1, #32
 267 003a 2046     		mov	r0, r4
 268 003c FFF7FEFF 		bl	canardEncodeScalar
 269              	.LVL25:
 189:Src/uavcan.c  ****     canardEncodeScalar(buffer, 34,  3, &node_mode);
 270              		.loc 1 189 0
 271 0040 0DF10603 		add	r3, sp, #6
 272 0044 0322     		movs	r2, #3
 273 0046 2221     		movs	r1, #34
 274 0048 2046     		mov	r0, r4
 275 004a FFF7FEFF 		bl	canardEncodeScalar
 276              	.LVL26:
 190:Src/uavcan.c  **** }
 277              		.loc 1 190 0
 278 004e 03B0     		add	sp, sp, #12
 279              	.LCFI4:
 280              		.cfi_def_cfa_offset 12
 281              		@ sp needed
 282 0050 30BD     		pop	{r4, r5, pc}
 283              	.LVL27:
 284              	.L30:
 285 0052 00BF     		.align	2
 286              	.L29:
 287 0054 D34D6210 		.word	274877907
 288              		.cfi_endproc
 289              	.LFE75:
 291              		.section	.text.spinCanard,"ax",%progbits
 292              		.align	1
 293              		.global	spinCanard
 294              		.syntax unified
 295              		.thumb
 296              		.thumb_func
 297              		.fpu softvfp
 299              	spinCanard:
 300              	.LFB73:
 157:Src/uavcan.c  ****     static uint32_t spin_time = 0;
 301              		.loc 1 157 0
 302              		.cfi_startproc
 303              		@ args = 0, pretend = 0, frame = 8
 304              		@ frame_needed = 0, uses_anonymous_args = 0
 305 0000 10B5     		push	{r4, lr}
 306              	.LCFI5:
 307              		.cfi_def_cfa_offset 8
 308              		.cfi_offset 4, -8
 309              		.cfi_offset 14, -4
 310 0002 88B0     		sub	sp, sp, #32
 311              	.LCFI6:
 312              		.cfi_def_cfa_offset 40
 159:Src/uavcan.c  ****     spin_time = HAL_GetTick();
 313              		.loc 1 159 0
 314 0004 FFF7FEFF 		bl	HAL_GetTick
 315              	.LVL28:
 316 0008 134B     		ldr	r3, .L36+8
ARM GAS  /tmp/cc1kQXNP.s 			page 10


 317 000a 1B68     		ldr	r3, [r3]
 318 000c 03F5FA73 		add	r3, r3, #500
 319 0010 9842     		cmp	r0, r3
 320 0012 01D2     		bcs	.L35
 321              	.L31:
 172:Src/uavcan.c  **** 
 322              		.loc 1 172 0
 323 0014 08B0     		add	sp, sp, #32
 324              	.LCFI7:
 325              		.cfi_remember_state
 326              		.cfi_def_cfa_offset 8
 327              		@ sp needed
 328 0016 10BD     		pop	{r4, pc}
 329              	.L35:
 330              	.LCFI8:
 331              		.cfi_restore_state
 160:Src/uavcan.c  ****     uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE];    
 332              		.loc 1 160 0
 333 0018 FFF7FEFF 		bl	HAL_GetTick
 334              	.LVL29:
 335 001c 0E4B     		ldr	r3, .L36+8
 336 001e 1860     		str	r0, [r3]
 163:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 337              		.loc 1 163 0
 338 0020 06AC     		add	r4, sp, #24
 339 0022 2046     		mov	r0, r4
 340 0024 FFF7FEFF 		bl	makeNodeStatusMessage
 341              	.LVL30:
 164:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
 342              		.loc 1 164 0
 343 0028 0723     		movs	r3, #7
 344 002a 0493     		str	r3, [sp, #16]
 345 002c 0394     		str	r4, [sp, #12]
 346 002e 1823     		movs	r3, #24
 347 0030 0293     		str	r3, [sp, #8]
 348 0032 0A4B     		ldr	r3, .L36+12
 349 0034 0193     		str	r3, [sp, #4]
 350 0036 40F25513 		movw	r3, #341
 351 003a 0093     		str	r3, [sp]
 352 003c 04A3     		adr	r3, .L36
 353 003e D3E90023 		ldrd	r2, [r3]
 354 0042 0748     		ldr	r0, .L36+16
 355 0044 FFF7FEFF 		bl	canardBroadcast
 356              	.LVL31:
 357 0048 E4E7     		b	.L31
 358              	.L37:
 359 004a 00BFAFF3 		.align	3
 359      0080
 360              	.L36:
 361 0050 F1C6A7C1 		.word	-1045969167
 362 0054 D068080F 		.word	252209360
 363 0058 00000000 		.word	.LANCHOR2
 364 005c 00000000 		.word	.LANCHOR3
 365 0060 00000000 		.word	.LANCHOR0
 366              		.cfi_endproc
 367              	.LFE73:
 369              		.section	.text.readUniqueID,"ax",%progbits
ARM GAS  /tmp/cc1kQXNP.s 			page 11


 370              		.align	1
 371              		.global	readUniqueID
 372              		.syntax unified
 373              		.thumb
 374              		.thumb_func
 375              		.fpu softvfp
 377              	readUniqueID:
 378              	.LFB77:
 191:Src/uavcan.c  **** 
 192:Src/uavcan.c  **** uint16_t makeNodeInfoMessage(uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE])
 193:Src/uavcan.c  **** {
 194:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
 195:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);
 196:Src/uavcan.c  ****    
 197:Src/uavcan.c  ****     buffer[7] = APP_VERSION_MAJOR;
 198:Src/uavcan.c  ****     buffer[8] = APP_VERSION_MINOR;
 199:Src/uavcan.c  ****     buffer[9] = 1;                          // Optional field flags, VCS commit is set
 200:Src/uavcan.c  ****     uint32_t u32 = GIT_HASH;
 201:Src/uavcan.c  ****     canardEncodeScalar(buffer, 80, 32, &u32); 
 202:Src/uavcan.c  ****     
 203:Src/uavcan.c  ****     readUniqueID(&buffer[24]);
 204:Src/uavcan.c  ****     const size_t name_len = strlen(APP_NODE_NAME);
 205:Src/uavcan.c  ****     memcpy(&buffer[41], APP_NODE_NAME, name_len);
 206:Src/uavcan.c  ****     return 41 + name_len ;
 207:Src/uavcan.c  **** }
 208:Src/uavcan.c  **** 
 209:Src/uavcan.c  **** void readUniqueID(uint8_t* out_uid)
 210:Src/uavcan.c  **** {
 379              		.loc 1 210 0
 380              		.cfi_startproc
 381              		@ args = 0, pretend = 0, frame = 0
 382              		@ frame_needed = 0, uses_anonymous_args = 0
 383              		@ link register save eliminated.
 384              	.LVL32:
 385              	.LBB7:
 211:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 386              		.loc 1 211 0
 387 0000 0023     		movs	r3, #0
 388 0002 02E0     		b	.L39
 389              	.LVL33:
 390              	.L40:
 212:Src/uavcan.c  ****     {
 213:Src/uavcan.c  ****         out_uid[i] = i;
 391              		.loc 1 213 0 discriminator 3
 392 0004 C354     		strb	r3, [r0, r3]
 211:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 393              		.loc 1 211 0 discriminator 3
 394 0006 0133     		adds	r3, r3, #1
 395              	.LVL34:
 396 0008 DBB2     		uxtb	r3, r3
 397              	.LVL35:
 398              	.L39:
 211:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 399              		.loc 1 211 0 is_stmt 0 discriminator 1
 400 000a 0F2B     		cmp	r3, #15
 401 000c FAD9     		bls	.L40
 402              	.LBE7:
ARM GAS  /tmp/cc1kQXNP.s 			page 12


 214:Src/uavcan.c  ****     }
 215:Src/uavcan.c  **** }
 403              		.loc 1 215 0 is_stmt 1
 404 000e 7047     		bx	lr
 405              		.cfi_endproc
 406              	.LFE77:
 408              		.section	.text.makeNodeInfoMessage,"ax",%progbits
 409              		.align	1
 410              		.global	makeNodeInfoMessage
 411              		.syntax unified
 412              		.thumb
 413              		.thumb_func
 414              		.fpu softvfp
 416              	makeNodeInfoMessage:
 417              	.LFB76:
 193:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
 418              		.loc 1 193 0
 419              		.cfi_startproc
 420              		@ args = 0, pretend = 0, frame = 8
 421              		@ frame_needed = 0, uses_anonymous_args = 0
 422              	.LVL36:
 423 0000 70B5     		push	{r4, r5, r6, lr}
 424              	.LCFI9:
 425              		.cfi_def_cfa_offset 16
 426              		.cfi_offset 4, -16
 427              		.cfi_offset 5, -12
 428              		.cfi_offset 6, -8
 429              		.cfi_offset 14, -4
 430 0002 82B0     		sub	sp, sp, #8
 431              	.LCFI10:
 432              		.cfi_def_cfa_offset 24
 433 0004 0546     		mov	r5, r0
 194:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);
 434              		.loc 1 194 0
 435 0006 40F27912 		movw	r2, #377
 436 000a 0021     		movs	r1, #0
 437 000c FFF7FEFF 		bl	memset
 438              	.LVL37:
 195:Src/uavcan.c  ****    
 439              		.loc 1 195 0
 440 0010 2846     		mov	r0, r5
 441 0012 FFF7FEFF 		bl	makeNodeStatusMessage
 442              	.LVL38:
 197:Src/uavcan.c  ****     buffer[8] = APP_VERSION_MINOR;
 443              		.loc 1 197 0
 444 0016 6323     		movs	r3, #99
 445 0018 EB71     		strb	r3, [r5, #7]
 198:Src/uavcan.c  ****     buffer[9] = 1;                          // Optional field flags, VCS commit is set
 446              		.loc 1 198 0
 447 001a 2B72     		strb	r3, [r5, #8]
 199:Src/uavcan.c  ****     uint32_t u32 = GIT_HASH;
 448              		.loc 1 199 0
 449 001c 0123     		movs	r3, #1
 450 001e 6B72     		strb	r3, [r5, #9]
 200:Src/uavcan.c  ****     canardEncodeScalar(buffer, 80, 32, &u32); 
 451              		.loc 1 200 0
 452 0020 02AB     		add	r3, sp, #8
ARM GAS  /tmp/cc1kQXNP.s 			page 13


 453 0022 0F4A     		ldr	r2, .L43
 454 0024 43F8042D 		str	r2, [r3, #-4]!
 201:Src/uavcan.c  ****     
 455              		.loc 1 201 0
 456 0028 2022     		movs	r2, #32
 457 002a 5021     		movs	r1, #80
 458 002c 2846     		mov	r0, r5
 459 002e FFF7FEFF 		bl	canardEncodeScalar
 460              	.LVL39:
 203:Src/uavcan.c  ****     const size_t name_len = strlen(APP_NODE_NAME);
 461              		.loc 1 203 0
 462 0032 05F11800 		add	r0, r5, #24
 463 0036 FFF7FEFF 		bl	readUniqueID
 464              	.LVL40:
 205:Src/uavcan.c  ****     return 41 + name_len ;
 465              		.loc 1 205 0
 466 003a 0A4C     		ldr	r4, .L43+4
 467 003c 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 468 003e C5F82900 		str	r0, [r5, #41]	@ unaligned
 469 0042 C5F82D10 		str	r1, [r5, #45]	@ unaligned
 470 0046 C5F83120 		str	r2, [r5, #49]	@ unaligned
 471 004a C5F83530 		str	r3, [r5, #53]	@ unaligned
 472 004e 2068     		ldr	r0, [r4]
 473 0050 C5F83900 		str	r0, [r5, #57]	@ unaligned
 474 0054 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 475 0056 85F83D30 		strb	r3, [r5, #61]
 207:Src/uavcan.c  **** 
 476              		.loc 1 207 0
 477 005a 3E20     		movs	r0, #62
 478 005c 02B0     		add	sp, sp, #8
 479              	.LCFI11:
 480              		.cfi_def_cfa_offset 16
 481              		@ sp needed
 482 005e 70BD     		pop	{r4, r5, r6, pc}
 483              	.LVL41:
 484              	.L44:
 485              		.align	2
 486              	.L43:
 487 0060 FE0FDCBA 		.word	-1159983106
 488 0064 00000000 		.word	.LC0
 489              		.cfi_endproc
 490              	.LFE76:
 492              		.section	.text.getNodeInfoHandleCanard,"ax",%progbits
 493              		.align	1
 494              		.global	getNodeInfoHandleCanard
 495              		.syntax unified
 496              		.thumb
 497              		.thumb_func
 498              		.fpu softvfp
 500              	getNodeInfoHandleCanard:
 501              	.LFB69:
  81:Src/uavcan.c  ****     uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE];
 502              		.loc 1 81 0
 503              		.cfi_startproc
 504              		@ args = 0, pretend = 0, frame = 384
 505              		@ frame_needed = 0, uses_anonymous_args = 0
 506              	.LVL42:
ARM GAS  /tmp/cc1kQXNP.s 			page 14


 507 0000 30B5     		push	{r4, r5, lr}
 508              	.LCFI12:
 509              		.cfi_def_cfa_offset 12
 510              		.cfi_offset 4, -12
 511              		.cfi_offset 5, -8
 512              		.cfi_offset 14, -4
 513 0002 E7B0     		sub	sp, sp, #412
 514              	.LCFI13:
 515              		.cfi_def_cfa_offset 424
 516 0004 0446     		mov	r4, r0
  83:Src/uavcan.c  ****     uint16_t len = makeNodeInfoMessage(buffer);
 517              		.loc 1 83 0
 518 0006 07AD     		add	r5, sp, #28
 519 0008 40F27912 		movw	r2, #377
 520 000c 0021     		movs	r1, #0
 521 000e 2846     		mov	r0, r5
 522              	.LVL43:
 523 0010 FFF7FEFF 		bl	memset
 524              	.LVL44:
  84:Src/uavcan.c  ****     int result = canardRequestOrRespond(&g_canard,
 525              		.loc 1 84 0
 526 0014 2846     		mov	r0, r5
 527 0016 FFF7FEFF 		bl	makeNodeInfoMessage
 528              	.LVL45:
  85:Src/uavcan.c  ****                                         transfer->source_node_id,
 529              		.loc 1 85 0
 530 001a E17E     		ldrb	r1, [r4, #27]	@ zero_extendqisi2
 531 001c 0590     		str	r0, [sp, #20]
 532 001e 0495     		str	r5, [sp, #16]
 533 0020 0023     		movs	r3, #0
 534 0022 0393     		str	r3, [sp, #12]
 535 0024 A37E     		ldrb	r3, [r4, #26]	@ zero_extendqisi2
 536 0026 0293     		str	r3, [sp, #8]
 537 0028 1934     		adds	r4, r4, #25
 538              	.LVL46:
 539 002a 0194     		str	r4, [sp, #4]
 540 002c 0123     		movs	r3, #1
 541 002e 0093     		str	r3, [sp]
 542 0030 04A3     		adr	r3, .L47+4
 543 0032 D3E90023 		ldrd	r2, [r3]
 544 0036 0248     		ldr	r0, .L47
 545              	.LVL47:
 546 0038 FFF7FEFF 		bl	canardRequestOrRespond
 547              	.LVL48:
  94:Src/uavcan.c  **** 
 548              		.loc 1 94 0
 549 003c 67B0     		add	sp, sp, #412
 550              	.LCFI14:
 551              		.cfi_def_cfa_offset 12
 552              		@ sp needed
 553 003e 30BD     		pop	{r4, r5, pc}
 554              	.LVL49:
 555              	.L48:
 556              		.align	3
 557              	.L47:
 558 0040 00000000 		.word	.LANCHOR0
 559 0044 9E6AC421 		.word	566520478
ARM GAS  /tmp/cc1kQXNP.s 			page 15


 560 0048 818A46EE 		.word	-297366911
 561              		.cfi_endproc
 562              	.LFE69:
 564              		.section	.text.pwmUpdate,"ax",%progbits
 565              		.align	1
 566              		.global	pwmUpdate
 567              		.syntax unified
 568              		.thumb
 569              		.thumb_func
 570              		.fpu softvfp
 572              	pwmUpdate:
 573              	.LFB79:
 216:Src/uavcan.c  **** 
 217:Src/uavcan.c  **** void rawcmdHandleCanard(CanardRxTransfer* transfer)
 218:Src/uavcan.c  **** {   
 219:Src/uavcan.c  ****     /*****/
 220:Src/uavcan.c  ****      
 221:Src/uavcan.c  ****     if(rawcommandTransfer==65535) rawcommandTransfer=0; 
 222:Src/uavcan.c  ****     rawcommandTransfer++;
 223:Src/uavcan.c  ****     int vaule;
 224:Src/uavcan.c  ****     int offset=((int)parameters[2].val*14);
 225:Src/uavcan.c  ****     canardDecodeScalar(transfer, offset, 14, true, &vaule);
 226:Src/uavcan.c  ****     pwmUpdate(vaule);
 227:Src/uavcan.c  **** 
 228:Src/uavcan.c  **** }
 229:Src/uavcan.c  **** 
 230:Src/uavcan.c  **** void pwmUpdate(uint16_t canVaule)
 231:Src/uavcan.c  **** {
 574              		.loc 1 231 0
 575              		.cfi_startproc
 576              		@ args = 0, pretend = 0, frame = 0
 577              		@ frame_needed = 0, uses_anonymous_args = 0
 578              		@ link register save eliminated.
 579              	.LVL50:
 232:Src/uavcan.c  ****    // canVaule+=1000;
 233:Src/uavcan.c  ****     int pwmVaule=canVaule/8;
 580              		.loc 1 233 0
 581 0000 C008     		lsrs	r0, r0, #3
 582              	.LVL51:
 234:Src/uavcan.c  ****     pwmVaule+=1000;
 583              		.loc 1 234 0
 584 0002 00F57A70 		add	r0, r0, #1000
 585              	.LVL52:
 235:Src/uavcan.c  ****     __HAL_TIM_SET_COMPARE(&htim3,TIM_CHANNEL_4,pwmVaule);
 586              		.loc 1 235 0
 587 0006 024B     		ldr	r3, .L50
 588 0008 1B68     		ldr	r3, [r3]
 589 000a 1864     		str	r0, [r3, #64]
 236:Src/uavcan.c  **** }
 590              		.loc 1 236 0
 591 000c 7047     		bx	lr
 592              	.L51:
 593 000e 00BF     		.align	2
 594              	.L50:
 595 0010 00000000 		.word	htim3
 596              		.cfi_endproc
 597              	.LFE79:
ARM GAS  /tmp/cc1kQXNP.s 			page 16


 599              		.section	.text.rawcmdHandleCanard,"ax",%progbits
 600              		.align	1
 601              		.global	rawcmdHandleCanard
 602              		.syntax unified
 603              		.thumb
 604              		.thumb_func
 605              		.fpu softvfp
 607              	rawcmdHandleCanard:
 608              	.LFB78:
 218:Src/uavcan.c  ****     /*****/
 609              		.loc 1 218 0
 610              		.cfi_startproc
 611              		@ args = 0, pretend = 0, frame = 8
 612              		@ frame_needed = 0, uses_anonymous_args = 0
 613              	.LVL53:
 614 0000 00B5     		push	{lr}
 615              	.LCFI15:
 616              		.cfi_def_cfa_offset 4
 617              		.cfi_offset 14, -4
 618 0002 85B0     		sub	sp, sp, #20
 619              	.LCFI16:
 620              		.cfi_def_cfa_offset 24
 221:Src/uavcan.c  ****     rawcommandTransfer++;
 621              		.loc 1 221 0
 622 0004 0F4B     		ldr	r3, .L56
 623 0006 1A88     		ldrh	r2, [r3]
 624 0008 4FF6FF73 		movw	r3, #65535
 625 000c 9A42     		cmp	r2, r3
 626 000e 15D0     		beq	.L55
 627              	.L53:
 222:Src/uavcan.c  ****     int vaule;
 628              		.loc 1 222 0
 629 0010 0C4A     		ldr	r2, .L56
 630 0012 1388     		ldrh	r3, [r2]
 631 0014 0133     		adds	r3, r3, #1
 632 0016 1380     		strh	r3, [r2]	@ movhi
 224:Src/uavcan.c  ****     canardDecodeScalar(transfer, offset, 14, true, &vaule);
 633              		.loc 1 224 0
 634 0018 0B4B     		ldr	r3, .L56+4
 635 001a 9B6D     		ldr	r3, [r3, #88]
 636 001c C3EBC303 		rsb	r3, r3, r3, lsl #3
 637 0020 5900     		lsls	r1, r3, #1
 638              	.LVL54:
 225:Src/uavcan.c  ****     pwmUpdate(vaule);
 639              		.loc 1 225 0
 640 0022 03AB     		add	r3, sp, #12
 641 0024 0093     		str	r3, [sp]
 642 0026 0123     		movs	r3, #1
 643 0028 0E22     		movs	r2, #14
 644 002a FFF7FEFF 		bl	canardDecodeScalar
 645              	.LVL55:
 226:Src/uavcan.c  **** 
 646              		.loc 1 226 0
 647 002e BDF80C00 		ldrh	r0, [sp, #12]
 648 0032 FFF7FEFF 		bl	pwmUpdate
 649              	.LVL56:
 228:Src/uavcan.c  **** 
ARM GAS  /tmp/cc1kQXNP.s 			page 17


 650              		.loc 1 228 0
 651 0036 05B0     		add	sp, sp, #20
 652              	.LCFI17:
 653              		.cfi_remember_state
 654              		.cfi_def_cfa_offset 4
 655              		@ sp needed
 656 0038 5DF804FB 		ldr	pc, [sp], #4
 657              	.LVL57:
 658              	.L55:
 659              	.LCFI18:
 660              		.cfi_restore_state
 221:Src/uavcan.c  ****     rawcommandTransfer++;
 661              		.loc 1 221 0 discriminator 1
 662 003c 014B     		ldr	r3, .L56
 663 003e 0022     		movs	r2, #0
 664 0040 1A80     		strh	r2, [r3]	@ movhi
 665 0042 E5E7     		b	.L53
 666              	.L57:
 667              		.align	2
 668              	.L56:
 669 0044 00000000 		.word	.LANCHOR4
 670 0048 00000000 		.word	.LANCHOR5
 671              		.cfi_endproc
 672              	.LFE78:
 674              		.section	.text.encodeParamCanard,"ax",%progbits
 675              		.align	1
 676              		.global	encodeParamCanard
 677              		.syntax unified
 678              		.thumb
 679              		.thumb_func
 680              		.fpu softvfp
 682              	encodeParamCanard:
 683              	.LFB82:
 237:Src/uavcan.c  **** 
 238:Src/uavcan.c  **** inline param_t * getParamByIndex(uint16_t index)
 239:Src/uavcan.c  **** {
 240:Src/uavcan.c  ****   if(index >= ARRAY_SIZE(parameters)) 
 241:Src/uavcan.c  ****   {
 242:Src/uavcan.c  ****     return NULL;
 243:Src/uavcan.c  ****   }
 244:Src/uavcan.c  **** 
 245:Src/uavcan.c  ****   return &parameters[index];
 246:Src/uavcan.c  **** }
 247:Src/uavcan.c  **** 
 248:Src/uavcan.c  ****  inline param_t * getParamByName(uint8_t * name)
 249:Src/uavcan.c  **** {
 250:Src/uavcan.c  ****   for(uint16_t i = 0; i < ARRAY_SIZE(parameters); i++)
 251:Src/uavcan.c  ****   {
 252:Src/uavcan.c  ****     if(strncmp((char const*)name, (char const*)parameters[i].name,strlen((char const*)parameters[i]
 253:Src/uavcan.c  ****     {
 254:Src/uavcan.c  ****       return &parameters[i];
 255:Src/uavcan.c  ****     }
 256:Src/uavcan.c  ****   }      
 257:Src/uavcan.c  ****   return NULL;
 258:Src/uavcan.c  **** }
 259:Src/uavcan.c  **** 
 260:Src/uavcan.c  ****  uint16_t encodeParamCanard(param_t * p, uint8_t * buffer)
ARM GAS  /tmp/cc1kQXNP.s 			page 18


 261:Src/uavcan.c  **** {
 684              		.loc 1 261 0
 685              		.cfi_startproc
 686              		@ args = 0, pretend = 0, frame = 8
 687              		@ frame_needed = 0, uses_anonymous_args = 0
 688              	.LVL58:
 689 0000 70B5     		push	{r4, r5, r6, lr}
 690              	.LCFI19:
 691              		.cfi_def_cfa_offset 16
 692              		.cfi_offset 4, -16
 693              		.cfi_offset 5, -12
 694              		.cfi_offset 6, -8
 695              		.cfi_offset 14, -4
 696 0002 82B0     		sub	sp, sp, #8
 697              	.LCFI20:
 698              		.cfi_def_cfa_offset 24
 699 0004 0C46     		mov	r4, r1
 262:Src/uavcan.c  ****     uint8_t n     = 0;
 700              		.loc 1 262 0
 701 0006 0023     		movs	r3, #0
 702 0008 8DF80730 		strb	r3, [sp, #7]
 703              	.LVL59:
 263:Src/uavcan.c  ****     int offset    = 0;
 264:Src/uavcan.c  ****     uint8_t tag   = 1;
 704              		.loc 1 264 0
 705 000c 0123     		movs	r3, #1
 706 000e 8DF80630 		strb	r3, [sp, #6]
 265:Src/uavcan.c  ****     if(p==NULL)
 707              		.loc 1 265 0
 708 0012 0028     		cmp	r0, #0
 709 0014 65D0     		beq	.L62
 710 0016 0546     		mov	r5, r0
 266:Src/uavcan.c  ****     {   
 267:Src/uavcan.c  ****         tag = 0;
 268:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 5, &n);
 269:Src/uavcan.c  ****         offset += 5;
 270:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset,3, &tag);
 271:Src/uavcan.c  ****         offset += 3;
 272:Src/uavcan.c  ****         
 273:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 6, &n);
 274:Src/uavcan.c  ****         offset += 6;
 275:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset,2, &tag);
 276:Src/uavcan.c  ****         offset += 2;
 277:Src/uavcan.c  ****         
 278:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 6, &n);
 279:Src/uavcan.c  ****         offset += 6;
 280:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 2, &tag);
 281:Src/uavcan.c  ****         offset += 2;
 282:Src/uavcan.c  ****         buffer[offset / 8] = 0;
 283:Src/uavcan.c  ****         return ( offset / 8 + 1 );
 284:Src/uavcan.c  ****     }
 285:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 5,&n);
 711              		.loc 1 285 0
 712 0018 0DF10703 		add	r3, sp, #7
 713 001c 0522     		movs	r2, #5
 714 001e 0021     		movs	r1, #0
 715              	.LVL60:
ARM GAS  /tmp/cc1kQXNP.s 			page 19


 716 0020 2046     		mov	r0, r4
 717              	.LVL61:
 718 0022 FFF7FEFF 		bl	canardEncodeScalar
 719              	.LVL62:
 286:Src/uavcan.c  ****     offset += 5;
 287:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 3, &tag);
 720              		.loc 1 287 0
 721 0026 0DF10603 		add	r3, sp, #6
 722 002a 0322     		movs	r2, #3
 723 002c 0521     		movs	r1, #5
 724 002e 2046     		mov	r0, r4
 725 0030 FFF7FEFF 		bl	canardEncodeScalar
 726              	.LVL63:
 288:Src/uavcan.c  ****     offset += 3;
 289:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 64, &p->val);
 727              		.loc 1 289 0
 728 0034 05F10803 		add	r3, r5, #8
 729 0038 4022     		movs	r2, #64
 730 003a 0821     		movs	r1, #8
 731 003c 2046     		mov	r0, r4
 732 003e FFF7FEFF 		bl	canardEncodeScalar
 733              	.LVL64:
 290:Src/uavcan.c  ****     offset += 64;
 291:Src/uavcan.c  ****     
 292:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 5, &n);
 734              		.loc 1 292 0
 735 0042 0DF10703 		add	r3, sp, #7
 736 0046 0522     		movs	r2, #5
 737 0048 4821     		movs	r1, #72
 738 004a 2046     		mov	r0, r4
 739 004c FFF7FEFF 		bl	canardEncodeScalar
 740              	.LVL65:
 293:Src/uavcan.c  ****     offset += 5;
 294:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 3, &tag);
 741              		.loc 1 294 0
 742 0050 0DF10603 		add	r3, sp, #6
 743 0054 0322     		movs	r2, #3
 744 0056 4D21     		movs	r1, #77
 745 0058 2046     		mov	r0, r4
 746 005a FFF7FEFF 		bl	canardEncodeScalar
 747              	.LVL66:
 295:Src/uavcan.c  ****     offset += 3;
 296:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 64, &p->defval);
 748              		.loc 1 296 0
 749 005e 05F12003 		add	r3, r5, #32
 750 0062 4022     		movs	r2, #64
 751 0064 5021     		movs	r1, #80
 752 0066 2046     		mov	r0, r4
 753 0068 FFF7FEFF 		bl	canardEncodeScalar
 754              	.LVL67:
 297:Src/uavcan.c  ****     offset += 64;
 298:Src/uavcan.c  ****     
 299:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 6, &n);
 755              		.loc 1 299 0
 756 006c 0DF10703 		add	r3, sp, #7
 757 0070 0622     		movs	r2, #6
 758 0072 9021     		movs	r1, #144
ARM GAS  /tmp/cc1kQXNP.s 			page 20


 759 0074 2046     		mov	r0, r4
 760 0076 FFF7FEFF 		bl	canardEncodeScalar
 761              	.LVL68:
 300:Src/uavcan.c  ****     offset += 6;
 301:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 2, &tag);
 762              		.loc 1 301 0
 763 007a 0DF10603 		add	r3, sp, #6
 764 007e 0222     		movs	r2, #2
 765 0080 9621     		movs	r1, #150
 766 0082 2046     		mov	r0, r4
 767 0084 FFF7FEFF 		bl	canardEncodeScalar
 768              	.LVL69:
 302:Src/uavcan.c  ****     offset += 2;
 303:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 64, &p->max);
 769              		.loc 1 303 0
 770 0088 05F11803 		add	r3, r5, #24
 771 008c 4022     		movs	r2, #64
 772 008e 9821     		movs	r1, #152
 773 0090 2046     		mov	r0, r4
 774 0092 FFF7FEFF 		bl	canardEncodeScalar
 775              	.LVL70:
 304:Src/uavcan.c  ****     offset += 64;
 305:Src/uavcan.c  ****     
 306:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 6, &n);
 776              		.loc 1 306 0
 777 0096 0DF10703 		add	r3, sp, #7
 778 009a 0622     		movs	r2, #6
 779 009c D821     		movs	r1, #216
 780 009e 2046     		mov	r0, r4
 781 00a0 FFF7FEFF 		bl	canardEncodeScalar
 782              	.LVL71:
 307:Src/uavcan.c  ****     offset += 6;
 308:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset,2,&tag);
 783              		.loc 1 308 0
 784 00a4 0DF10603 		add	r3, sp, #6
 785 00a8 0222     		movs	r2, #2
 786 00aa DE21     		movs	r1, #222
 787 00ac 2046     		mov	r0, r4
 788 00ae FFF7FEFF 		bl	canardEncodeScalar
 789              	.LVL72:
 309:Src/uavcan.c  ****     offset += 2;
 310:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset,64,&p->min);
 790              		.loc 1 310 0
 791 00b2 05F11003 		add	r3, r5, #16
 792 00b6 4022     		movs	r2, #64
 793 00b8 E021     		movs	r1, #224
 794 00ba 2046     		mov	r0, r4
 795 00bc FFF7FEFF 		bl	canardEncodeScalar
 796              	.LVL73:
 311:Src/uavcan.c  ****     offset += 64;
 312:Src/uavcan.c  ****     
 313:Src/uavcan.c  ****     memcpy(&buffer[offset / 8], p->name, strlen((char const*)p->name));
 797              		.loc 1 313 0
 798 00c0 2434     		adds	r4, r4, #36
 799              	.LVL74:
 800 00c2 2E68     		ldr	r6, [r5]
 801 00c4 3046     		mov	r0, r6
ARM GAS  /tmp/cc1kQXNP.s 			page 21


 802 00c6 FFF7FEFF 		bl	strlen
 803              	.LVL75:
 804 00ca 0246     		mov	r2, r0
 805 00cc 3146     		mov	r1, r6
 806 00ce 2046     		mov	r0, r4
 807 00d0 FFF7FEFF 		bl	memcpy
 808              	.LVL76:
 314:Src/uavcan.c  ****     return  (offset/8 + strlen((char const*)p->name)); 
 809              		.loc 1 314 0
 810 00d4 2868     		ldr	r0, [r5]
 811 00d6 FFF7FEFF 		bl	strlen
 812              	.LVL77:
 813 00da 2430     		adds	r0, r0, #36
 814 00dc 80B2     		uxth	r0, r0
 815              	.LVL78:
 816              	.L60:
 315:Src/uavcan.c  **** }
 817              		.loc 1 315 0
 818 00de 02B0     		add	sp, sp, #8
 819              	.LCFI21:
 820              		.cfi_remember_state
 821              		.cfi_def_cfa_offset 16
 822              		@ sp needed
 823 00e0 70BD     		pop	{r4, r5, r6, pc}
 824              	.LVL79:
 825              	.L62:
 826              	.LCFI22:
 827              		.cfi_restore_state
 267:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 5, &n);
 828              		.loc 1 267 0
 829 00e2 0025     		movs	r5, #0
 830 00e4 8DF80650 		strb	r5, [sp, #6]
 268:Src/uavcan.c  ****         offset += 5;
 831              		.loc 1 268 0
 832 00e8 0DF10703 		add	r3, sp, #7
 833 00ec 0522     		movs	r2, #5
 834 00ee 2946     		mov	r1, r5
 835              	.LVL80:
 836 00f0 2046     		mov	r0, r4
 837              	.LVL81:
 838 00f2 FFF7FEFF 		bl	canardEncodeScalar
 839              	.LVL82:
 270:Src/uavcan.c  ****         offset += 3;
 840              		.loc 1 270 0
 841 00f6 0DF10603 		add	r3, sp, #6
 842 00fa 0322     		movs	r2, #3
 843 00fc 0521     		movs	r1, #5
 844 00fe 2046     		mov	r0, r4
 845 0100 FFF7FEFF 		bl	canardEncodeScalar
 846              	.LVL83:
 273:Src/uavcan.c  ****         offset += 6;
 847              		.loc 1 273 0
 848 0104 0DF10703 		add	r3, sp, #7
 849 0108 0622     		movs	r2, #6
 850 010a 0821     		movs	r1, #8
 851 010c 2046     		mov	r0, r4
 852 010e FFF7FEFF 		bl	canardEncodeScalar
ARM GAS  /tmp/cc1kQXNP.s 			page 22


 853              	.LVL84:
 275:Src/uavcan.c  ****         offset += 2;
 854              		.loc 1 275 0
 855 0112 0DF10603 		add	r3, sp, #6
 856 0116 0222     		movs	r2, #2
 857 0118 0E21     		movs	r1, #14
 858 011a 2046     		mov	r0, r4
 859 011c FFF7FEFF 		bl	canardEncodeScalar
 860              	.LVL85:
 278:Src/uavcan.c  ****         offset += 6;
 861              		.loc 1 278 0
 862 0120 0DF10703 		add	r3, sp, #7
 863 0124 0622     		movs	r2, #6
 864 0126 1021     		movs	r1, #16
 865 0128 2046     		mov	r0, r4
 866 012a FFF7FEFF 		bl	canardEncodeScalar
 867              	.LVL86:
 280:Src/uavcan.c  ****         offset += 2;
 868              		.loc 1 280 0
 869 012e 0DF10603 		add	r3, sp, #6
 870 0132 0222     		movs	r2, #2
 871 0134 1621     		movs	r1, #22
 872 0136 2046     		mov	r0, r4
 873 0138 FFF7FEFF 		bl	canardEncodeScalar
 874              	.LVL87:
 282:Src/uavcan.c  ****         return ( offset / 8 + 1 );
 875              		.loc 1 282 0
 876 013c E570     		strb	r5, [r4, #3]
 283:Src/uavcan.c  ****     }
 877              		.loc 1 283 0
 878 013e 0420     		movs	r0, #4
 879 0140 CDE7     		b	.L60
 880              		.cfi_endproc
 881              	.LFE82:
 883              		.section	.text.parametersLoad,"ax",%progbits
 884              		.align	1
 885              		.global	parametersLoad
 886              		.syntax unified
 887              		.thumb
 888              		.thumb_func
 889              		.fpu softvfp
 891              	parametersLoad:
 892              	.LFB85:
 316:Src/uavcan.c  **** 
 317:Src/uavcan.c  ****  void getsetHandleCanard(CanardRxTransfer* transfer)
 318:Src/uavcan.c  **** {
 319:Src/uavcan.c  ****     uint16_t index = 0xFFFF;
 320:Src/uavcan.c  ****     uint8_t tag    = 0;
 321:Src/uavcan.c  ****     int offset     = 0;
 322:Src/uavcan.c  ****     int64_t val    = 0;
 323:Src/uavcan.c  ****     HAL_UART_Transmit(&huart1,"OK",2,0xffff); 
 324:Src/uavcan.c  ****     canardDecodeScalar(transfer, offset, 13, false, &index);
 325:Src/uavcan.c  ****     offset += 13;
 326:Src/uavcan.c  ****     canardDecodeScalar(transfer, offset, 3, false, &tag);
 327:Src/uavcan.c  ****     offset += 3;
 328:Src/uavcan.c  **** 
 329:Src/uavcan.c  ****     if(tag == 1)
ARM GAS  /tmp/cc1kQXNP.s 			page 23


 330:Src/uavcan.c  ****     {
 331:Src/uavcan.c  ****         canardDecodeScalar(transfer, offset, 64, false, &val);
 332:Src/uavcan.c  ****         offset += 64;
 333:Src/uavcan.c  ****     } 
 334:Src/uavcan.c  **** 
 335:Src/uavcan.c  ****     uint16_t n = transfer->payload_len - offset / 8 ;
 336:Src/uavcan.c  ****     uint8_t name[16]      = "";
 337:Src/uavcan.c  ****     for(int i = 0; i < n; i++)
 338:Src/uavcan.c  ****     {
 339:Src/uavcan.c  ****         canardDecodeScalar(transfer, offset, 8, false, &name[i]);
 340:Src/uavcan.c  ****         offset += 8;
 341:Src/uavcan.c  ****     }
 342:Src/uavcan.c  **** 
 343:Src/uavcan.c  ****     param_t * p = NULL;
 344:Src/uavcan.c  **** 
 345:Src/uavcan.c  ****     if(strlen((char const*)name))
 346:Src/uavcan.c  ****     {
 347:Src/uavcan.c  ****         p = getParamByName(name);
 348:Src/uavcan.c  ****     }
 349:Src/uavcan.c  ****     else
 350:Src/uavcan.c  ****     {
 351:Src/uavcan.c  ****         p = getParamByIndex(index);
 352:Src/uavcan.c  ****     }
 353:Src/uavcan.c  **** 
 354:Src/uavcan.c  ****     if((p)&&(tag == 1))
 355:Src/uavcan.c  ****     {
 356:Src/uavcan.c  ****         p->val = val;
 357:Src/uavcan.c  ****     }
 358:Src/uavcan.c  ****     uint8_t  buffer[64] = "";
 359:Src/uavcan.c  ****     uint16_t len = encodeParamCanard(p, buffer);
 360:Src/uavcan.c  ****     int result = canardRequestOrRespond(&g_canard,
 361:Src/uavcan.c  ****                                         transfer->source_node_id,
 362:Src/uavcan.c  ****                                         UAVCAN_PROTOCOL_PARAM_GETSET_SIGNATURE,
 363:Src/uavcan.c  ****                                         UAVCAN_PROTOCOL_PARAM_GETSET_ID,
 364:Src/uavcan.c  ****                                         &transfer->transfer_id,
 365:Src/uavcan.c  ****                                         transfer->priority,
 366:Src/uavcan.c  ****                                         CanardResponse,
 367:Src/uavcan.c  ****                                         &buffer[0],
 368:Src/uavcan.c  ****                                         (uint16_t)len);
 369:Src/uavcan.c  **** 
 370:Src/uavcan.c  ****    
 371:Src/uavcan.c  ****      parametersSave();
 372:Src/uavcan.c  **** }
 373:Src/uavcan.c  **** 
 374:Src/uavcan.c  **** 
 375:Src/uavcan.c  **** void ledStatus()
 376:Src/uavcan.c  **** {
 377:Src/uavcan.c  ****   signalTag(rawcommandTransfer);
 378:Src/uavcan.c  **** }
 379:Src/uavcan.c  **** 
 380:Src/uavcan.c  **** void parametersLoad()
 381:Src/uavcan.c  **** {
 893              		.loc 1 381 0
 894              		.cfi_startproc
 895              		@ args = 0, pretend = 0, frame = 0
 896              		@ frame_needed = 0, uses_anonymous_args = 0
 897 0000 10B5     		push	{r4, lr}
ARM GAS  /tmp/cc1kQXNP.s 			page 24


 898              	.LCFI23:
 899              		.cfi_def_cfa_offset 8
 900              		.cfi_offset 4, -8
 901              		.cfi_offset 14, -4
 382:Src/uavcan.c  ****       //**setup parameters from flash data**//
 383:Src/uavcan.c  ****     StmFlashRead(FlashAddress,FlashData,4);  
 902              		.loc 1 383 0
 903 0002 0C4C     		ldr	r4, .L65
 904 0004 0422     		movs	r2, #4
 905 0006 2146     		mov	r1, r4
 906 0008 0B4B     		ldr	r3, .L65+4
 907 000a 1868     		ldr	r0, [r3]
 908 000c FFF7FEFF 		bl	StmFlashRead
 909              	.LVL88:
 384:Src/uavcan.c  ****     parameters[0].val=FlashData[0];
 910              		.loc 1 384 0
 911 0010 2088     		ldrh	r0, [r4]
 912 0012 0021     		movs	r1, #0
 913 0014 094B     		ldr	r3, .L65+8
 914 0016 C3E90201 		strd	r0, [r3, #8]
 385:Src/uavcan.c  ****     parameters[1].val=FlashData[1];
 915              		.loc 1 385 0
 916 001a 6088     		ldrh	r0, [r4, #2]
 917 001c 0021     		movs	r1, #0
 918 001e C3E90C01 		strd	r0, [r3, #48]
 386:Src/uavcan.c  ****     parameters[2].val=FlashData[2];
 919              		.loc 1 386 0
 920 0022 A088     		ldrh	r0, [r4, #4]
 921 0024 0021     		movs	r1, #0
 922 0026 C3E91601 		strd	r0, [r3, #88]
 387:Src/uavcan.c  ****     parameters[3].val=FlashData[3];
 923              		.loc 1 387 0
 924 002a E088     		ldrh	r0, [r4, #6]
 925 002c 0021     		movs	r1, #0
 926 002e C3E92001 		strd	r0, [r3, #128]
 388:Src/uavcan.c  ****   
 389:Src/uavcan.c  ****     
 390:Src/uavcan.c  **** }
 927              		.loc 1 390 0
 928 0032 10BD     		pop	{r4, pc}
 929              	.L66:
 930              		.align	2
 931              	.L65:
 932 0034 00000000 		.word	FlashData
 933 0038 00000000 		.word	.LANCHOR6
 934 003c 00000000 		.word	.LANCHOR5
 935              		.cfi_endproc
 936              	.LFE85:
 938              		.section	.text.parametersSave,"ax",%progbits
 939              		.align	1
 940              		.global	parametersSave
 941              		.syntax unified
 942              		.thumb
 943              		.thumb_func
 944              		.fpu softvfp
 946              	parametersSave:
 947              	.LFB86:
ARM GAS  /tmp/cc1kQXNP.s 			page 25


 391:Src/uavcan.c  **** 
 392:Src/uavcan.c  **** void parametersSave()
 393:Src/uavcan.c  **** {
 948              		.loc 1 393 0
 949              		.cfi_startproc
 950              		@ args = 0, pretend = 0, frame = 0
 951              		@ frame_needed = 0, uses_anonymous_args = 0
 952 0000 08B5     		push	{r3, lr}
 953              	.LCFI24:
 954              		.cfi_def_cfa_offset 8
 955              		.cfi_offset 3, -8
 956              		.cfi_offset 14, -4
 394:Src/uavcan.c  ****     FlashData[0]=parameters[0].val;
 957              		.loc 1 394 0
 958 0002 084B     		ldr	r3, .L69
 959 0004 9A68     		ldr	r2, [r3, #8]
 960 0006 0849     		ldr	r1, .L69+4
 961 0008 0A80     		strh	r2, [r1]	@ movhi
 395:Src/uavcan.c  ****     FlashData[1]=parameters[1].val;  
 962              		.loc 1 395 0
 963 000a 1A6B     		ldr	r2, [r3, #48]
 964 000c 4A80     		strh	r2, [r1, #2]	@ movhi
 396:Src/uavcan.c  ****     FlashData[2]=parameters[2].val;  
 965              		.loc 1 396 0
 966 000e 9A6D     		ldr	r2, [r3, #88]
 967 0010 8A80     		strh	r2, [r1, #4]	@ movhi
 397:Src/uavcan.c  ****     FlashData[3]=parameters[3].val;  
 968              		.loc 1 397 0
 969 0012 D3F88030 		ldr	r3, [r3, #128]
 970 0016 CB80     		strh	r3, [r1, #6]	@ movhi
 398:Src/uavcan.c  ****                 
 399:Src/uavcan.c  ****     StmFlashWrite(FlashAddress,FlashData,4);   
 971              		.loc 1 399 0
 972 0018 0422     		movs	r2, #4
 973 001a 044B     		ldr	r3, .L69+8
 974 001c 1868     		ldr	r0, [r3]
 975 001e FFF7FEFF 		bl	StmFlashWrite
 976              	.LVL89:
 400:Src/uavcan.c  **** }
 977              		.loc 1 400 0
 978 0022 08BD     		pop	{r3, pc}
 979              	.L70:
 980              		.align	2
 981              	.L69:
 982 0024 00000000 		.word	.LANCHOR5
 983 0028 00000000 		.word	FlashData
 984 002c 00000000 		.word	.LANCHOR6
 985              		.cfi_endproc
 986              	.LFE86:
 988              		.section	.text.getsetHandleCanard,"ax",%progbits
 989              		.align	1
 990              		.global	getsetHandleCanard
 991              		.syntax unified
 992              		.thumb
 993              		.thumb_func
 994              		.fpu softvfp
 996              	getsetHandleCanard:
ARM GAS  /tmp/cc1kQXNP.s 			page 26


 997              	.LFB83:
 318:Src/uavcan.c  ****     uint16_t index = 0xFFFF;
 998              		.loc 1 318 0
 999              		.cfi_startproc
 1000              		@ args = 0, pretend = 0, frame = 96
 1001              		@ frame_needed = 0, uses_anonymous_args = 0
 1002              	.LVL90:
 1003 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1004              	.LCFI25:
 1005              		.cfi_def_cfa_offset 20
 1006              		.cfi_offset 4, -20
 1007              		.cfi_offset 5, -16
 1008              		.cfi_offset 6, -12
 1009              		.cfi_offset 7, -8
 1010              		.cfi_offset 14, -4
 1011 0002 9FB0     		sub	sp, sp, #124
 1012              	.LCFI26:
 1013              		.cfi_def_cfa_offset 144
 1014 0004 0646     		mov	r6, r0
 319:Src/uavcan.c  ****     uint8_t tag    = 0;
 1015              		.loc 1 319 0
 1016 0006 4FF6FF73 		movw	r3, #65535
 1017 000a ADF87630 		strh	r3, [sp, #118]	@ movhi
 320:Src/uavcan.c  ****     int offset     = 0;
 1018              		.loc 1 320 0
 1019 000e 0024     		movs	r4, #0
 1020 0010 8DF87540 		strb	r4, [sp, #117]
 1021              	.LVL91:
 322:Src/uavcan.c  ****     HAL_UART_Transmit(&huart1,"OK",2,0xffff); 
 1022              		.loc 1 322 0
 1023 0014 0020     		movs	r0, #0
 1024              	.LVL92:
 1025 0016 0021     		movs	r1, #0
 1026 0018 CDE91A01 		strd	r0, [sp, #104]
 323:Src/uavcan.c  ****     canardDecodeScalar(transfer, offset, 13, false, &index);
 1027              		.loc 1 323 0
 1028 001c 0222     		movs	r2, #2
 1029 001e 4E49     		ldr	r1, .L93+8
 1030 0020 4E48     		ldr	r0, .L93+12
 1031 0022 FFF7FEFF 		bl	HAL_UART_Transmit
 1032              	.LVL93:
 324:Src/uavcan.c  ****     offset += 13;
 1033              		.loc 1 324 0
 1034 0026 0DF17603 		add	r3, sp, #118
 1035 002a 0093     		str	r3, [sp]
 1036 002c 2346     		mov	r3, r4
 1037 002e 0D22     		movs	r2, #13
 1038 0030 2146     		mov	r1, r4
 1039 0032 3046     		mov	r0, r6
 1040 0034 FFF7FEFF 		bl	canardDecodeScalar
 1041              	.LVL94:
 326:Src/uavcan.c  ****     offset += 3;
 1042              		.loc 1 326 0
 1043 0038 0DF17503 		add	r3, sp, #117
 1044 003c 0093     		str	r3, [sp]
 1045 003e 2346     		mov	r3, r4
 1046 0040 0322     		movs	r2, #3
ARM GAS  /tmp/cc1kQXNP.s 			page 27


 1047 0042 0D21     		movs	r1, #13
 1048 0044 3046     		mov	r0, r6
 1049 0046 FFF7FEFF 		bl	canardDecodeScalar
 1050              	.LVL95:
 329:Src/uavcan.c  ****     {
 1051              		.loc 1 329 0
 1052 004a 9DF87530 		ldrb	r3, [sp, #117]	@ zero_extendqisi2
 1053 004e 012B     		cmp	r3, #1
 1054 0050 0FD0     		beq	.L88
 327:Src/uavcan.c  **** 
 1055              		.loc 1 327 0
 1056 0052 1025     		movs	r5, #16
 1057              	.LVL96:
 1058              	.L72:
 335:Src/uavcan.c  ****     uint8_t name[16]      = "";
 1059              		.loc 1 335 0
 1060 0054 B78A     		ldrh	r7, [r6, #20]
 1061 0056 2B46     		mov	r3, r5
 1062 0058 002D     		cmp	r5, #0
 1063 005a 14DB     		blt	.L89
 1064              	.L73:
 1065 005c DB10     		asrs	r3, r3, #3
 1066 005e 5B42     		negs	r3, r3
 1067 0060 9BB2     		uxth	r3, r3
 1068 0062 1F44     		add	r7, r7, r3
 1069 0064 BFB2     		uxth	r7, r7
 1070              	.LVL97:
 336:Src/uavcan.c  ****     for(int i = 0; i < n; i++)
 1071              		.loc 1 336 0
 1072 0066 0024     		movs	r4, #0
 1073 0068 1694     		str	r4, [sp, #88]
 1074 006a 1794     		str	r4, [sp, #92]
 1075 006c 1894     		str	r4, [sp, #96]
 1076 006e 1994     		str	r4, [sp, #100]
 1077              	.LVL98:
 1078              	.LBB14:
 337:Src/uavcan.c  ****     {
 1079              		.loc 1 337 0
 1080 0070 16E0     		b	.L74
 1081              	.LVL99:
 1082              	.L88:
 1083              	.LBE14:
 331:Src/uavcan.c  ****         offset += 64;
 1084              		.loc 1 331 0
 1085 0072 1AAB     		add	r3, sp, #104
 1086 0074 0093     		str	r3, [sp]
 1087 0076 2346     		mov	r3, r4
 1088 0078 4022     		movs	r2, #64
 1089 007a 1021     		movs	r1, #16
 1090 007c 3046     		mov	r0, r6
 1091 007e FFF7FEFF 		bl	canardDecodeScalar
 1092              	.LVL100:
 332:Src/uavcan.c  ****     } 
 1093              		.loc 1 332 0
 1094 0082 5025     		movs	r5, #80
 1095 0084 E6E7     		b	.L72
 1096              	.LVL101:
ARM GAS  /tmp/cc1kQXNP.s 			page 28


 1097              	.L89:
 335:Src/uavcan.c  ****     uint8_t name[16]      = "";
 1098              		.loc 1 335 0
 1099 0086 EB1D     		adds	r3, r5, #7
 1100              	.LVL102:
 1101 0088 E8E7     		b	.L73
 1102              	.LVL103:
 1103              	.L75:
 1104              	.LBB15:
 339:Src/uavcan.c  ****         offset += 8;
 1105              		.loc 1 339 0 discriminator 3
 1106 008a 16AB     		add	r3, sp, #88
 1107 008c 2344     		add	r3, r3, r4
 1108 008e 0093     		str	r3, [sp]
 1109 0090 0023     		movs	r3, #0
 1110 0092 0822     		movs	r2, #8
 1111 0094 2946     		mov	r1, r5
 1112 0096 3046     		mov	r0, r6
 1113 0098 FFF7FEFF 		bl	canardDecodeScalar
 1114              	.LVL104:
 340:Src/uavcan.c  ****     }
 1115              		.loc 1 340 0 discriminator 3
 1116 009c 0835     		adds	r5, r5, #8
 1117              	.LVL105:
 337:Src/uavcan.c  ****     {
 1118              		.loc 1 337 0 discriminator 3
 1119 009e 0134     		adds	r4, r4, #1
 1120              	.LVL106:
 1121              	.L74:
 337:Src/uavcan.c  ****     {
 1122              		.loc 1 337 0 is_stmt 0 discriminator 1
 1123 00a0 A742     		cmp	r7, r4
 1124 00a2 F2DC     		bgt	.L75
 1125              	.LVL107:
 1126              	.LBE15:
 345:Src/uavcan.c  ****     {
 1127              		.loc 1 345 0 is_stmt 1
 1128 00a4 9DF85830 		ldrb	r3, [sp, #88]	@ zero_extendqisi2
 1129 00a8 7BB9     		cbnz	r3, .L84
 351:Src/uavcan.c  ****     }
 1130              		.loc 1 351 0
 1131 00aa BDF87630 		ldrh	r3, [sp, #118]
 1132              	.LVL108:
 1133              	.LBB16:
 1134              	.LBB17:
 240:Src/uavcan.c  ****   {
 1135              		.loc 1 240 0
 1136 00ae 032B     		cmp	r3, #3
 1137 00b0 4BD8     		bhi	.L85
 245:Src/uavcan.c  **** }
 1138              		.loc 1 245 0
 1139 00b2 03EB8303 		add	r3, r3, r3, lsl #2
 1140              	.LVL109:
 1141 00b6 DA00     		lsls	r2, r3, #3
 1142 00b8 294D     		ldr	r5, .L93+16
 1143              	.LVL110:
 1144 00ba 1544     		add	r5, r5, r2
ARM GAS  /tmp/cc1kQXNP.s 			page 29


 1145              	.LVL111:
 1146 00bc 1BE0     		b	.L81
 1147              	.LVL112:
 1148              	.L91:
 1149              	.LBE17:
 1150              	.LBE16:
 1151              	.LBB19:
 1152              	.LBB20:
 1153              	.LBB21:
 254:Src/uavcan.c  ****     }
 1154              		.loc 1 254 0
 1155 00be 04EB8407 		add	r7, r4, r4, lsl #2
 1156              	.LVL113:
 1157 00c2 FB00     		lsls	r3, r7, #3
 1158 00c4 264D     		ldr	r5, .L93+16
 1159 00c6 1D44     		add	r5, r5, r3
 1160 00c8 15E0     		b	.L81
 1161              	.LVL114:
 1162              	.L84:
 250:Src/uavcan.c  ****   {
 1163              		.loc 1 250 0
 1164 00ca 0024     		movs	r4, #0
 1165              	.LVL115:
 1166              	.L76:
 1167 00cc 032C     		cmp	r4, #3
 1168 00ce 11D8     		bhi	.L90
 252:Src/uavcan.c  ****     {
 1169              		.loc 1 252 0
 1170 00d0 04EB8402 		add	r2, r4, r4, lsl #2
 1171 00d4 D300     		lsls	r3, r2, #3
 1172 00d6 224A     		ldr	r2, .L93+16
 1173 00d8 D558     		ldr	r5, [r2, r3]
 1174 00da 2846     		mov	r0, r5
 1175 00dc FFF7FEFF 		bl	strlen
 1176              	.LVL116:
 1177 00e0 0246     		mov	r2, r0
 1178 00e2 2946     		mov	r1, r5
 1179 00e4 16A8     		add	r0, sp, #88
 1180 00e6 FFF7FEFF 		bl	strncmp
 1181              	.LVL117:
 1182 00ea 0028     		cmp	r0, #0
 1183 00ec E7D0     		beq	.L91
 250:Src/uavcan.c  ****   {
 1184              		.loc 1 250 0
 1185 00ee 0134     		adds	r4, r4, #1
 1186              	.LVL118:
 1187 00f0 A4B2     		uxth	r4, r4
 1188              	.LVL119:
 1189 00f2 EBE7     		b	.L76
 1190              	.L90:
 1191              	.LBE21:
 257:Src/uavcan.c  **** }
 1192              		.loc 1 257 0
 1193 00f4 0025     		movs	r5, #0
 1194              	.LVL120:
 1195              	.L81:
 1196              	.LBE20:
ARM GAS  /tmp/cc1kQXNP.s 			page 30


 1197              	.LBE19:
 354:Src/uavcan.c  ****     {
 1198              		.loc 1 354 0
 1199 00f6 1DB1     		cbz	r5, .L82
 354:Src/uavcan.c  ****     {
 1200              		.loc 1 354 0 is_stmt 0 discriminator 1
 1201 00f8 9DF87530 		ldrb	r3, [sp, #117]	@ zero_extendqisi2
 1202 00fc 012B     		cmp	r3, #1
 1203 00fe 1FD0     		beq	.L92
 1204              	.LVL121:
 1205              	.L82:
 358:Src/uavcan.c  ****     uint16_t len = encodeParamCanard(p, buffer);
 1206              		.loc 1 358 0 is_stmt 1
 1207 0100 0024     		movs	r4, #0
 1208 0102 0694     		str	r4, [sp, #24]
 1209 0104 3C22     		movs	r2, #60
 1210 0106 2146     		mov	r1, r4
 1211 0108 07A8     		add	r0, sp, #28
 1212 010a FFF7FEFF 		bl	memset
 1213              	.LVL122:
 359:Src/uavcan.c  ****     int result = canardRequestOrRespond(&g_canard,
 1214              		.loc 1 359 0
 1215 010e 06AF     		add	r7, sp, #24
 1216 0110 3946     		mov	r1, r7
 1217 0112 2846     		mov	r0, r5
 1218 0114 FFF7FEFF 		bl	encodeParamCanard
 1219              	.LVL123:
 360:Src/uavcan.c  ****                                         transfer->source_node_id,
 1220              		.loc 1 360 0
 1221 0118 F17E     		ldrb	r1, [r6, #27]	@ zero_extendqisi2
 1222 011a 0590     		str	r0, [sp, #20]
 1223 011c 0497     		str	r7, [sp, #16]
 1224 011e 0394     		str	r4, [sp, #12]
 1225 0120 B37E     		ldrb	r3, [r6, #26]	@ zero_extendqisi2
 1226 0122 0293     		str	r3, [sp, #8]
 1227 0124 1936     		adds	r6, r6, #25
 1228              	.LVL124:
 1229 0126 0196     		str	r6, [sp, #4]
 1230 0128 0B23     		movs	r3, #11
 1231 012a 0093     		str	r3, [sp]
 1232 012c 08A3     		adr	r3, .L93
 1233 012e D3E90023 		ldrd	r2, [r3]
 1234 0132 0C48     		ldr	r0, .L93+20
 1235              	.LVL125:
 1236 0134 FFF7FEFF 		bl	canardRequestOrRespond
 1237              	.LVL126:
 371:Src/uavcan.c  **** }
 1238              		.loc 1 371 0
 1239 0138 FFF7FEFF 		bl	parametersSave
 1240              	.LVL127:
 372:Src/uavcan.c  **** 
 1241              		.loc 1 372 0
 1242 013c 1FB0     		add	sp, sp, #124
 1243              	.LCFI27:
 1244              		.cfi_remember_state
 1245              		.cfi_def_cfa_offset 20
 1246              		@ sp needed
ARM GAS  /tmp/cc1kQXNP.s 			page 31


 1247 013e F0BD     		pop	{r4, r5, r6, r7, pc}
 1248              	.LVL128:
 1249              	.L92:
 1250              	.LCFI28:
 1251              		.cfi_restore_state
 356:Src/uavcan.c  ****     }
 1252              		.loc 1 356 0
 1253 0140 DDE91A23 		ldrd	r2, [sp, #104]
 1254 0144 C5E90223 		strd	r2, [r5, #8]
 1255 0148 DAE7     		b	.L82
 1256              	.LVL129:
 1257              	.L85:
 1258              	.LBB22:
 1259              	.LBB18:
 242:Src/uavcan.c  ****   }
 1260              		.loc 1 242 0
 1261 014a 0025     		movs	r5, #0
 1262              	.LVL130:
 1263 014c D8E7     		b	.L82
 1264              	.L94:
 1265 014e 00BF     		.align	3
 1266              	.L93:
 1267 0150 D5A4D139 		.word	970040533
 1268 0154 F922B6A7 		.word	-1481235719
 1269 0158 00000000 		.word	.LC1
 1270 015c 00000000 		.word	huart1
 1271 0160 00000000 		.word	.LANCHOR5
 1272 0164 00000000 		.word	.LANCHOR0
 1273              	.LBE18:
 1274              	.LBE22:
 1275              		.cfi_endproc
 1276              	.LFE83:
 1278              		.section	.text.onTransferReceived,"ax",%progbits
 1279              		.align	1
 1280              		.global	onTransferReceived
 1281              		.syntax unified
 1282              		.thumb
 1283              		.thumb_func
 1284              		.fpu softvfp
 1286              	onTransferReceived:
 1287              	.LFB68:
  64:Src/uavcan.c  ****     if ((transfer->transfer_type == CanardTransferTypeRequest) && (transfer->data_type_id == UAVCAN
 1288              		.loc 1 64 0
 1289              		.cfi_startproc
 1290              		@ args = 0, pretend = 0, frame = 0
 1291              		@ frame_needed = 0, uses_anonymous_args = 0
 1292              	.LVL131:
 1293 0000 10B5     		push	{r4, lr}
 1294              	.LCFI29:
 1295              		.cfi_def_cfa_offset 8
 1296              		.cfi_offset 4, -8
 1297              		.cfi_offset 14, -4
 1298 0002 0C46     		mov	r4, r1
  65:Src/uavcan.c  ****     {
 1299              		.loc 1 65 0
 1300 0004 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 1301 0006 012B     		cmp	r3, #1
ARM GAS  /tmp/cc1kQXNP.s 			page 32


 1302 0008 08D0     		beq	.L100
 1303              	.LVL132:
 1304              	.L96:
  69:Src/uavcan.c  ****     {
 1305              		.loc 1 69 0
 1306 000a E28A     		ldrh	r2, [r4, #22]
 1307 000c 40F20643 		movw	r3, #1030
 1308 0010 9A42     		cmp	r2, r3
 1309 0012 0AD0     		beq	.L101
 1310              	.L97:
  73:Src/uavcan.c  ****     {
 1311              		.loc 1 73 0
 1312 0014 E38A     		ldrh	r3, [r4, #22]
 1313 0016 0B2B     		cmp	r3, #11
 1314 0018 0BD0     		beq	.L102
 1315              	.L95:
  78:Src/uavcan.c  **** 
 1316              		.loc 1 78 0
 1317 001a 10BD     		pop	{r4, pc}
 1318              	.LVL133:
 1319              	.L100:
  65:Src/uavcan.c  ****     {
 1320              		.loc 1 65 0 discriminator 1
 1321 001c CB8A     		ldrh	r3, [r1, #22]
 1322 001e 012B     		cmp	r3, #1
 1323 0020 F3D1     		bne	.L96
  67:Src/uavcan.c  ****     } 
 1324              		.loc 1 67 0
 1325 0022 0846     		mov	r0, r1
 1326              	.LVL134:
 1327 0024 FFF7FEFF 		bl	getNodeInfoHandleCanard
 1328              	.LVL135:
 1329 0028 EFE7     		b	.L96
 1330              	.L101:
  71:Src/uavcan.c  ****     }
 1331              		.loc 1 71 0
 1332 002a 2046     		mov	r0, r4
 1333 002c FFF7FEFF 		bl	rawcmdHandleCanard
 1334              	.LVL136:
 1335 0030 F0E7     		b	.L97
 1336              	.L102:
  75:Src/uavcan.c  ****     }
 1337              		.loc 1 75 0
 1338 0032 2046     		mov	r0, r4
 1339 0034 FFF7FEFF 		bl	getsetHandleCanard
 1340              	.LVL137:
  78:Src/uavcan.c  **** 
 1341              		.loc 1 78 0
 1342 0038 EFE7     		b	.L95
 1343              		.cfi_endproc
 1344              	.LFE68:
 1346              		.section	.text.parameterCheck,"ax",%progbits
 1347              		.align	1
 1348              		.global	parameterCheck
 1349              		.syntax unified
 1350              		.thumb
 1351              		.thumb_func
ARM GAS  /tmp/cc1kQXNP.s 			page 33


 1352              		.fpu softvfp
 1354              	parameterCheck:
 1355              	.LFB87:
 401:Src/uavcan.c  **** 
 402:Src/uavcan.c  **** void parameterCheck()
 403:Src/uavcan.c  **** {
 1356              		.loc 1 403 0
 1357              		.cfi_startproc
 1358              		@ args = 0, pretend = 0, frame = 0
 1359              		@ frame_needed = 0, uses_anonymous_args = 0
 1360              		@ link register save eliminated.
 404:Src/uavcan.c  ****     if(parameters[0].val>127 || parameters[0].val<1)
 1361              		.loc 1 404 0
 1362 0000 1B4B     		ldr	r3, .L108
 1363 0002 D3E90201 		ldrd	r0, [r3, #8]
 1364 0006 10F1FF32 		adds	r2, r0, #-1
 1365 000a 41F1FF33 		adc	r3, r1, #-1
 1366 000e 002B     		cmp	r3, #0
 1367 0010 08BF     		it	eq
 1368 0012 7F2A     		cmpeq	r2, #127
 1369 0014 04D3     		bcc	.L104
 405:Src/uavcan.c  ****         parameters[0].val=99;
 1370              		.loc 1 405 0
 1371 0016 164B     		ldr	r3, .L108
 1372 0018 6320     		movs	r0, #99
 1373 001a 0021     		movs	r1, #0
 1374 001c C3E90201 		strd	r0, [r3, #8]
 1375              	.L104:
 406:Src/uavcan.c  ****     if(parameters[1].val>100)
 1376              		.loc 1 406 0
 1377 0020 134B     		ldr	r3, .L108
 1378 0022 D3E90C23 		ldrd	r2, [r3, #48]
 1379 0026 652A     		cmp	r2, #101
 1380 0028 73F10003 		sbcs	r3, r3, #0
 1381 002c 04DB     		blt	.L105
 407:Src/uavcan.c  ****         parameters[1].val=10;
 1382              		.loc 1 407 0
 1383 002e 104B     		ldr	r3, .L108
 1384 0030 0A20     		movs	r0, #10
 1385 0032 0021     		movs	r1, #0
 1386 0034 C3E90C01 		strd	r0, [r3, #48]
 1387              	.L105:
 408:Src/uavcan.c  ****     if(parameters[2].val>20)
 1388              		.loc 1 408 0
 1389 0038 0D4B     		ldr	r3, .L108
 1390 003a D3E91623 		ldrd	r2, [r3, #88]
 1391 003e 152A     		cmp	r2, #21
 1392 0040 73F10003 		sbcs	r3, r3, #0
 1393 0044 04DB     		blt	.L106
 409:Src/uavcan.c  ****         parameters[2].val=0;
 1394              		.loc 1 409 0
 1395 0046 0A4B     		ldr	r3, .L108
 1396 0048 0020     		movs	r0, #0
 1397 004a 0021     		movs	r1, #0
 1398 004c C3E91601 		strd	r0, [r3, #88]
 1399              	.L106:
 410:Src/uavcan.c  ****     if(parameters[3].val>1000)
ARM GAS  /tmp/cc1kQXNP.s 			page 34


 1400              		.loc 1 410 0
 1401 0050 074B     		ldr	r3, .L108
 1402 0052 D3E92023 		ldrd	r2, [r3, #128]
 1403 0056 4FF47A70 		mov	r0, #1000
 1404 005a 0021     		movs	r1, #0
 1405 005c 9042     		cmp	r0, r2
 1406 005e 71EB0303 		sbcs	r3, r1, r3
 1407 0062 04DA     		bge	.L103
 411:Src/uavcan.c  ****         parameters[3].val=0;
 1408              		.loc 1 411 0
 1409 0064 024B     		ldr	r3, .L108
 1410 0066 0020     		movs	r0, #0
 1411 0068 0021     		movs	r1, #0
 1412 006a C3E92001 		strd	r0, [r3, #128]
 1413              	.L103:
 412:Src/uavcan.c  **** }
 1414              		.loc 1 412 0
 1415 006e 7047     		bx	lr
 1416              	.L109:
 1417              		.align	2
 1418              	.L108:
 1419 0070 00000000 		.word	.LANCHOR5
 1420              		.cfi_endproc
 1421              	.LFE87:
 1423              		.section	.text.uavcanInit,"ax",%progbits
 1424              		.align	1
 1425              		.global	uavcanInit
 1426              		.syntax unified
 1427              		.thumb
 1428              		.thumb_func
 1429              		.fpu softvfp
 1431              	uavcanInit:
 1432              	.LFB70:
  97:Src/uavcan.c  ****     parametersLoad();
 1433              		.loc 1 97 0
 1434              		.cfi_startproc
 1435              		@ args = 0, pretend = 0, frame = 8
 1436              		@ frame_needed = 0, uses_anonymous_args = 0
 1437 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1438              	.LCFI30:
 1439              		.cfi_def_cfa_offset 20
 1440              		.cfi_offset 4, -20
 1441              		.cfi_offset 5, -16
 1442              		.cfi_offset 6, -12
 1443              		.cfi_offset 7, -8
 1444              		.cfi_offset 14, -4
 1445 0002 85B0     		sub	sp, sp, #20
 1446              	.LCFI31:
 1447              		.cfi_def_cfa_offset 40
  98:Src/uavcan.c  ****     parameterCheck();
 1448              		.loc 1 98 0
 1449 0004 FFF7FEFF 		bl	parametersLoad
 1450              	.LVL138:
  99:Src/uavcan.c  ****     nodeID=parameters[0].val;
 1451              		.loc 1 99 0
 1452 0008 FFF7FEFF 		bl	parameterCheck
 1453              	.LVL139:
ARM GAS  /tmp/cc1kQXNP.s 			page 35


 100:Src/uavcan.c  ****     CanardSTM32CANTimings timings;
 1454              		.loc 1 100 0
 1455 000c 4A4B     		ldr	r3, .L133
 1456 000e 9A68     		ldr	r2, [r3, #8]
 1457 0010 4A4B     		ldr	r3, .L133+4
 1458 0012 1A70     		strb	r2, [r3]
 102:Src/uavcan.c  ****     if (result)
 1459              		.loc 1 102 0
 1460 0014 FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 1461              	.LVL140:
 1462              	.LBB26:
 1463              	.LBB27:
 1464              		.file 2 "libcanard/drivers/stm32/canard_stm32.h"
   1:libcanard/drivers/stm32/canard_stm32.h **** /*
   2:libcanard/drivers/stm32/canard_stm32.h ****  * Copyright (c) 2017 UAVCAN Team
   3:libcanard/drivers/stm32/canard_stm32.h ****  *
   4:libcanard/drivers/stm32/canard_stm32.h ****  * Distributed under the MIT License, available in the file LICENSE.
   5:libcanard/drivers/stm32/canard_stm32.h ****  *
   6:libcanard/drivers/stm32/canard_stm32.h ****  * Author: Pavel Kirienko <pavel.kirienko@zubax.com>
   7:libcanard/drivers/stm32/canard_stm32.h ****  */
   8:libcanard/drivers/stm32/canard_stm32.h **** 
   9:libcanard/drivers/stm32/canard_stm32.h **** #ifndef CANARD_STM32_H
  10:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_H
  11:libcanard/drivers/stm32/canard_stm32.h **** 
  12:libcanard/drivers/stm32/canard_stm32.h **** #include <canard.h>
  13:libcanard/drivers/stm32/canard_stm32.h **** #include <string.h>     // NOLINT
  14:libcanard/drivers/stm32/canard_stm32.h **** 
  15:libcanard/drivers/stm32/canard_stm32.h **** 
  16:libcanard/drivers/stm32/canard_stm32.h **** #ifdef __cplusplus
  17:libcanard/drivers/stm32/canard_stm32.h **** extern "C"
  18:libcanard/drivers/stm32/canard_stm32.h **** {
  19:libcanard/drivers/stm32/canard_stm32.h **** #endif
  20:libcanard/drivers/stm32/canard_stm32.h **** 
  21:libcanard/drivers/stm32/canard_stm32.h **** /**
  22:libcanard/drivers/stm32/canard_stm32.h ****  * Set this build config macro to 1 to use CAN2 instead of CAN1, if available.
  23:libcanard/drivers/stm32/canard_stm32.h ****  * Setting this parameter when CAN2 is not available may not be detected at compile time!
  24:libcanard/drivers/stm32/canard_stm32.h ****  */
  25:libcanard/drivers/stm32/canard_stm32.h **** #if !defined(CANARD_STM32_USE_CAN2)
  26:libcanard/drivers/stm32/canard_stm32.h **** # define CANARD_STM32_USE_CAN2                                  0
  27:libcanard/drivers/stm32/canard_stm32.h **** #endif
  28:libcanard/drivers/stm32/canard_stm32.h **** 
  29:libcanard/drivers/stm32/canard_stm32.h **** /**
  30:libcanard/drivers/stm32/canard_stm32.h ****  * Trigger an assertion failure if inner priority inversion is detected at run time.
  31:libcanard/drivers/stm32/canard_stm32.h ****  * This setting has no effect in release builds, where NDEBUG is defined.
  32:libcanard/drivers/stm32/canard_stm32.h ****  */
  33:libcanard/drivers/stm32/canard_stm32.h **** #if !defined(CANARD_STM32_DEBUG_INNER_PRIORITY_INVERSION)
  34:libcanard/drivers/stm32/canard_stm32.h **** # define CANARD_STM32_DEBUG_INNER_PRIORITY_INVERSION            1
  35:libcanard/drivers/stm32/canard_stm32.h **** #endif
  36:libcanard/drivers/stm32/canard_stm32.h **** 
  37:libcanard/drivers/stm32/canard_stm32.h **** /**
  38:libcanard/drivers/stm32/canard_stm32.h ****  * Driver error codes.
  39:libcanard/drivers/stm32/canard_stm32.h ****  * These values are returned negated from API functions that return int.
  40:libcanard/drivers/stm32/canard_stm32.h ****  */
  41:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE                         1000
  42:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_MSR_INAK_NOT_SET                             1001
  43:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_MSR_INAK_NOT_CLEARED                         1002
  44:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_UNSUPPORTED_FRAME_FORMAT                     1003
ARM GAS  /tmp/cc1kQXNP.s 			page 36


  45:libcanard/drivers/stm32/canard_stm32.h **** 
  46:libcanard/drivers/stm32/canard_stm32.h **** /**
  47:libcanard/drivers/stm32/canard_stm32.h ****  * This is defined by the bxCAN hardware.
  48:libcanard/drivers/stm32/canard_stm32.h ****  * Devices with only one CAN interface have 14 filters (e.g. F103).
  49:libcanard/drivers/stm32/canard_stm32.h ****  * Devices with two CAN interfaces have 28 filters, which are shared between two interfaces (e.g. F
  50:libcanard/drivers/stm32/canard_stm32.h ****  * The filters are distributed between CAN1 and CAN2 by means of the CAN2 start filter bank selecti
  51:libcanard/drivers/stm32/canard_stm32.h ****  * which is a number from 1 to 27 inclusive. Seeing as the start bank cannot be set to 0, CAN2 has 
  52:libcanard/drivers/stm32/canard_stm32.h ****  * to use.
  53:libcanard/drivers/stm32/canard_stm32.h ****  */
  54:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_NUM_ACCEPTANCE_FILTERS                            14U
  55:libcanard/drivers/stm32/canard_stm32.h **** 
  56:libcanard/drivers/stm32/canard_stm32.h **** /**
  57:libcanard/drivers/stm32/canard_stm32.h ****  * The interface can be initialized in either of these modes.
  58:libcanard/drivers/stm32/canard_stm32.h ****  *
  59:libcanard/drivers/stm32/canard_stm32.h ****  * The Silent mode is useful for automatic CAN bit rate detection, where the interface is initializ
  60:libcanard/drivers/stm32/canard_stm32.h ****  * arbitrarily guessed CAN bit rate (typically either 1 Mbps, 500 Kbps, 250 Kbps, or 125 Kbps, thes
  61:libcanard/drivers/stm32/canard_stm32.h ****  * standard values defined by the UAVCAN specification), and the bus is then listened for 1 second 
  62:libcanard/drivers/stm32/canard_stm32.h ****  * determine whether the bit rate was guessed correctly. It is paramount to use the silent mode in 
  63:libcanard/drivers/stm32/canard_stm32.h ****  * as to not interfere with ongoing communications on the bus if the guess was incorrect.
  64:libcanard/drivers/stm32/canard_stm32.h ****  *
  65:libcanard/drivers/stm32/canard_stm32.h ****  * The automatic TX abort on error mode should be used during dynamic node ID allocation. The reaso
  66:libcanard/drivers/stm32/canard_stm32.h ****  * is well explained in the UAVCAN specification, please read it.
  67:libcanard/drivers/stm32/canard_stm32.h ****  *
  68:libcanard/drivers/stm32/canard_stm32.h ****  * The normal mode should be used for all other use cases, particularly for the normal operation of
  69:libcanard/drivers/stm32/canard_stm32.h ****  * hence the name.
  70:libcanard/drivers/stm32/canard_stm32.h ****  */
  71:libcanard/drivers/stm32/canard_stm32.h **** typedef enum
  72:libcanard/drivers/stm32/canard_stm32.h **** {
  73:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeNormal,                         //!< Normal mode
  74:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeSilent,                         //!< Do not affect the bus, only listen
  75:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeAutomaticTxAbortOnError         //!< Abort pending TX if a bus error has oc
  76:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32IfaceMode;
  77:libcanard/drivers/stm32/canard_stm32.h **** 
  78:libcanard/drivers/stm32/canard_stm32.h **** /**
  79:libcanard/drivers/stm32/canard_stm32.h ****  * Interface statistics; these values can be queried using a dedicated API call.
  80:libcanard/drivers/stm32/canard_stm32.h ****  */
  81:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
  82:libcanard/drivers/stm32/canard_stm32.h **** {
  83:libcanard/drivers/stm32/canard_stm32.h ****     uint64_t rx_overflow_count;
  84:libcanard/drivers/stm32/canard_stm32.h ****     uint64_t error_count;
  85:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32Stats;
  86:libcanard/drivers/stm32/canard_stm32.h **** 
  87:libcanard/drivers/stm32/canard_stm32.h **** /**
  88:libcanard/drivers/stm32/canard_stm32.h ****  * ID and Mask of a hardware acceptance filter.
  89:libcanard/drivers/stm32/canard_stm32.h ****  * The ID and Mask fields support flags @ref CANARD_CAN_FRAME_EFF and @ref CANARD_CAN_FRAME_RTR.
  90:libcanard/drivers/stm32/canard_stm32.h ****  */
  91:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
  92:libcanard/drivers/stm32/canard_stm32.h **** {
  93:libcanard/drivers/stm32/canard_stm32.h ****     uint32_t id;
  94:libcanard/drivers/stm32/canard_stm32.h ****     uint32_t mask;
  95:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32AcceptanceFilterConfiguration;
  96:libcanard/drivers/stm32/canard_stm32.h **** 
  97:libcanard/drivers/stm32/canard_stm32.h **** /**
  98:libcanard/drivers/stm32/canard_stm32.h ****  * These parameters define the timings of the CAN controller.
  99:libcanard/drivers/stm32/canard_stm32.h ****  * Please refer to the documentation of the bxCAN macrocell for explanation.
 100:libcanard/drivers/stm32/canard_stm32.h ****  * These values can be computed by the developed beforehand if ROM size is of a concern,
 101:libcanard/drivers/stm32/canard_stm32.h ****  * or they can be computed at run time using the function defined below.
ARM GAS  /tmp/cc1kQXNP.s 			page 37


 102:libcanard/drivers/stm32/canard_stm32.h ****  */
 103:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
 104:libcanard/drivers/stm32/canard_stm32.h **** {
 105:libcanard/drivers/stm32/canard_stm32.h ****     uint16_t bit_rate_prescaler;                        /// [1, 1024]
 106:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bit_segment_1;                              /// [1, 16]
 107:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bit_segment_2;                              /// [1, 8]
 108:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t max_resynchronization_jump_width;           /// [1, 4] (recommended value is 1)
 109:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32CANTimings;
 110:libcanard/drivers/stm32/canard_stm32.h **** 
 111:libcanard/drivers/stm32/canard_stm32.h **** /**
 112:libcanard/drivers/stm32/canard_stm32.h ****  * Initializes the CAN controller at the specified bit rate.
 113:libcanard/drivers/stm32/canard_stm32.h ****  * The mode can be either normal, silent, or auto-abort on error;
 114:libcanard/drivers/stm32/canard_stm32.h ****  * in silent mode the controller will be only listening, not affecting the state of the bus;
 115:libcanard/drivers/stm32/canard_stm32.h ****  * in the auto abort mode the controller will cancel the pending transmissions if a bus error is en
 116:libcanard/drivers/stm32/canard_stm32.h ****  * The auto abort mode is needed for dynamic node ID allocation procedure; please refer to the UAVC
 117:libcanard/drivers/stm32/canard_stm32.h ****  * for more information about this topic.
 118:libcanard/drivers/stm32/canard_stm32.h ****  *
 119:libcanard/drivers/stm32/canard_stm32.h ****  * This function can be invoked any number of times; every invocation re-initializes everything fro
 120:libcanard/drivers/stm32/canard_stm32.h ****  *
 121:libcanard/drivers/stm32/canard_stm32.h ****  * WARNING: The clock of the CAN module must be enabled before this function is invoked!
 122:libcanard/drivers/stm32/canard_stm32.h ****  *          If CAN2 is used, CAN1 must be also enabled!
 123:libcanard/drivers/stm32/canard_stm32.h ****  *
 124:libcanard/drivers/stm32/canard_stm32.h ****  * WARNING: The driver is not thread-safe!
 125:libcanard/drivers/stm32/canard_stm32.h ****  *          It does not use IRQ or critical sections though, so it is safe to invoke its API functi
 126:libcanard/drivers/stm32/canard_stm32.h ****  *          IRQ context from the application.
 127:libcanard/drivers/stm32/canard_stm32.h ****  *
 128:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               Success
 129:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 130:libcanard/drivers/stm32/canard_stm32.h ****  */
 131:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Init(const CanardSTM32CANTimings* const timings,
 132:libcanard/drivers/stm32/canard_stm32.h ****                         const CanardSTM32IfaceMode iface_mode);
 133:libcanard/drivers/stm32/canard_stm32.h **** 
 134:libcanard/drivers/stm32/canard_stm32.h **** /**
 135:libcanard/drivers/stm32/canard_stm32.h ****  * Pushes one frame into the TX buffer, if there is space.
 136:libcanard/drivers/stm32/canard_stm32.h ****  * Note that proper care is taken to ensure that no inner priority inversion is taking place.
 137:libcanard/drivers/stm32/canard_stm32.h ****  * This function does never block.
 138:libcanard/drivers/stm32/canard_stm32.h ****  *
 139:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      1               Transmitted successfully
 140:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               No space in the buffer
 141:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 142:libcanard/drivers/stm32/canard_stm32.h ****  */
 143:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Transmit(const CanardCANFrame* const frame);
 144:libcanard/drivers/stm32/canard_stm32.h **** 
 145:libcanard/drivers/stm32/canard_stm32.h **** /**
 146:libcanard/drivers/stm32/canard_stm32.h ****  * Reads one frame from the hardware RX FIFO, unless all FIFO are empty.
 147:libcanard/drivers/stm32/canard_stm32.h ****  * This function does never block.
 148:libcanard/drivers/stm32/canard_stm32.h ****  *
 149:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      1               Read successfully
 150:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               The buffer is empty
 151:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 152:libcanard/drivers/stm32/canard_stm32.h ****  */
 153:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Receive(CanardCANFrame* const out_frame);
 154:libcanard/drivers/stm32/canard_stm32.h **** 
 155:libcanard/drivers/stm32/canard_stm32.h **** /**
 156:libcanard/drivers/stm32/canard_stm32.h ****  * Sets up acceptance filters according to the provided list of ID and masks.
 157:libcanard/drivers/stm32/canard_stm32.h ****  * Note that when the interface is reinitialized, hardware acceptance filters are reset.
 158:libcanard/drivers/stm32/canard_stm32.h ****  * Also note that during filter reconfiguration, some RX frames may be lost.
ARM GAS  /tmp/cc1kQXNP.s 			page 38


 159:libcanard/drivers/stm32/canard_stm32.h ****  *
 160:libcanard/drivers/stm32/canard_stm32.h ****  * Setting zero filters will result in rejection of all frames.
 161:libcanard/drivers/stm32/canard_stm32.h ****  * In order to accept all frames, set one filter with ID = Mask = 0, which is also the default conf
 162:libcanard/drivers/stm32/canard_stm32.h ****  *
 163:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               Success
 164:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 165:libcanard/drivers/stm32/canard_stm32.h ****  */
 166:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32ConfigureAcceptanceFilters(const CanardSTM32AcceptanceFilterConfiguration* const
 167:libcanard/drivers/stm32/canard_stm32.h ****                                               const uint8_t num_filter_configs);
 168:libcanard/drivers/stm32/canard_stm32.h **** 
 169:libcanard/drivers/stm32/canard_stm32.h **** /**
 170:libcanard/drivers/stm32/canard_stm32.h ****  * Returns the running interface statistics.
 171:libcanard/drivers/stm32/canard_stm32.h ****  */
 172:libcanard/drivers/stm32/canard_stm32.h **** CanardSTM32Stats canardSTM32GetStats(void);
 173:libcanard/drivers/stm32/canard_stm32.h **** 
 174:libcanard/drivers/stm32/canard_stm32.h **** /**
 175:libcanard/drivers/stm32/canard_stm32.h ****  * Given the rate of the clock supplied to the bxCAN macrocell (typically PCLK1) and the desired bi
 176:libcanard/drivers/stm32/canard_stm32.h ****  * this function iteratively solves for the best possible timing settings. The CAN bus timing param
 177:libcanard/drivers/stm32/canard_stm32.h ****  * such as the sample point location, the number of time quantas per bit, etc., are optimized accor
 178:libcanard/drivers/stm32/canard_stm32.h ****  * recommendations provided in the specifications of UAVCAN, DeviceNet, and CANOpen.
 179:libcanard/drivers/stm32/canard_stm32.h ****  *
 180:libcanard/drivers/stm32/canard_stm32.h ****  * Unless noted otherwise, all units are SI units; particularly, frequency is specified in hertz.
 181:libcanard/drivers/stm32/canard_stm32.h ****  *
 182:libcanard/drivers/stm32/canard_stm32.h ****  * The implementation is adapted from libuavcan.
 183:libcanard/drivers/stm32/canard_stm32.h ****  *
 184:libcanard/drivers/stm32/canard_stm32.h ****  * This function is defined in the header in order to encourage the linker to discard it if it is n
 185:libcanard/drivers/stm32/canard_stm32.h ****  *
 186:libcanard/drivers/stm32/canard_stm32.h ****  * @retval 0            Success
 187:libcanard/drivers/stm32/canard_stm32.h ****  * @retval negative     Solution could not be found for the provided inputs.
 188:libcanard/drivers/stm32/canard_stm32.h ****  */
 189:libcanard/drivers/stm32/canard_stm32.h **** static inline
 190:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32ComputeCANTimings(const uint32_t peripheral_clock_rate,
 191:libcanard/drivers/stm32/canard_stm32.h ****                                      const uint32_t target_bitrate,
 192:libcanard/drivers/stm32/canard_stm32.h ****                                      CanardSTM32CANTimings* const out_timings)
 193:libcanard/drivers/stm32/canard_stm32.h **** {
 194:libcanard/drivers/stm32/canard_stm32.h ****     if (target_bitrate < 1000)
 195:libcanard/drivers/stm32/canard_stm32.h ****     {
 196:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 197:libcanard/drivers/stm32/canard_stm32.h ****     }
 198:libcanard/drivers/stm32/canard_stm32.h **** 
 199:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(out_timings != NULL);  // NOLINT
 200:libcanard/drivers/stm32/canard_stm32.h ****     memset(out_timings, 0, sizeof(*out_timings));
 1465              		.loc 2 200 0
 1466 0018 0023     		movs	r3, #0
 1467 001a 0293     		str	r3, [sp, #8]
 1468 001c ADF80C30 		strh	r3, [sp, #12]	@ movhi
 201:libcanard/drivers/stm32/canard_stm32.h **** 
 202:libcanard/drivers/stm32/canard_stm32.h ****     /*
 203:libcanard/drivers/stm32/canard_stm32.h ****      * Hardware configuration
 204:libcanard/drivers/stm32/canard_stm32.h ****      */
 205:libcanard/drivers/stm32/canard_stm32.h ****     static const uint8_t MaxBS1 = 16;
 206:libcanard/drivers/stm32/canard_stm32.h ****     static const uint8_t MaxBS2 = 8;
 207:libcanard/drivers/stm32/canard_stm32.h **** 
 208:libcanard/drivers/stm32/canard_stm32.h ****     /*
 209:libcanard/drivers/stm32/canard_stm32.h ****      * Ref. "Automatic Baudrate Detection in CANopen Networks", U. Koppe, MicroControl GmbH & Co. K
 210:libcanard/drivers/stm32/canard_stm32.h ****      *      CAN in Automation, 2003
 211:libcanard/drivers/stm32/canard_stm32.h ****      *
ARM GAS  /tmp/cc1kQXNP.s 			page 39


 212:libcanard/drivers/stm32/canard_stm32.h ****      * According to the source, optimal quanta per bit are:
 213:libcanard/drivers/stm32/canard_stm32.h ****      *   Bitrate        Optimal Maximum
 214:libcanard/drivers/stm32/canard_stm32.h ****      *   1000 kbps      8       10
 215:libcanard/drivers/stm32/canard_stm32.h ****      *   500  kbps      16      17
 216:libcanard/drivers/stm32/canard_stm32.h ****      *   250  kbps      16      17
 217:libcanard/drivers/stm32/canard_stm32.h ****      *   125  kbps      16      17
 218:libcanard/drivers/stm32/canard_stm32.h ****      */
 219:libcanard/drivers/stm32/canard_stm32.h ****     const uint8_t max_quanta_per_bit = (uint8_t)((target_bitrate >= 1000000) ? 10 : 17);    // NOLI
 220:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(max_quanta_per_bit <= (MaxBS1 + MaxBS2));
 221:libcanard/drivers/stm32/canard_stm32.h **** 
 222:libcanard/drivers/stm32/canard_stm32.h ****     static const uint16_t MaxSamplePointLocationPermill = 900;
 223:libcanard/drivers/stm32/canard_stm32.h **** 
 224:libcanard/drivers/stm32/canard_stm32.h ****     /*
 225:libcanard/drivers/stm32/canard_stm32.h ****      * Computing (prescaler * BS):
 226:libcanard/drivers/stm32/canard_stm32.h ****      *   BITRATE = 1 / (PRESCALER * (1 / PCLK) * (1 + BS1 + BS2))       -- See the Reference Manual
 227:libcanard/drivers/stm32/canard_stm32.h ****      *   BITRATE = PCLK / (PRESCALER * (1 + BS1 + BS2))                 -- Simplified
 228:libcanard/drivers/stm32/canard_stm32.h ****      * let:
 229:libcanard/drivers/stm32/canard_stm32.h ****      *   BS = 1 + BS1 + BS2                                             -- Number of time quanta pe
 230:libcanard/drivers/stm32/canard_stm32.h ****      *   PRESCALER_BS = PRESCALER * BS
 231:libcanard/drivers/stm32/canard_stm32.h ****      * ==>
 232:libcanard/drivers/stm32/canard_stm32.h ****      *   PRESCALER_BS = PCLK / BITRATE
 233:libcanard/drivers/stm32/canard_stm32.h ****      */
 234:libcanard/drivers/stm32/canard_stm32.h ****     const uint32_t prescaler_bs = peripheral_clock_rate / target_bitrate;
 1469              		.loc 2 234 0
 1470 0020 474C     		ldr	r4, .L133+8
 1471 0022 A4FB0034 		umull	r3, r4, r4, r0
 1472 0026 A40C     		lsrs	r4, r4, #18
 1473              	.LVL141:
 235:libcanard/drivers/stm32/canard_stm32.h **** 
 236:libcanard/drivers/stm32/canard_stm32.h ****     /*
 237:libcanard/drivers/stm32/canard_stm32.h ****      * Searching for such prescaler value so that the number of quanta per bit is highest.
 238:libcanard/drivers/stm32/canard_stm32.h ****      */
 239:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);    // NOLINT
 1474              		.loc 2 239 0
 1475 0028 0923     		movs	r3, #9
 1476              	.LVL142:
 1477              	.L111:
 240:libcanard/drivers/stm32/canard_stm32.h **** 
 241:libcanard/drivers/stm32/canard_stm32.h ****     while ((prescaler_bs % (1U + bs1_bs2_sum)) != 0)
 1478              		.loc 2 241 0
 1479 002a 591C     		adds	r1, r3, #1
 1480 002c B4FBF1F2 		udiv	r2, r4, r1
 1481 0030 01FB1242 		mls	r2, r1, r2, r4
 1482 0034 22B1     		cbz	r2, .L129
 242:libcanard/drivers/stm32/canard_stm32.h ****     {
 243:libcanard/drivers/stm32/canard_stm32.h ****         if (bs1_bs2_sum <= 2)
 1483              		.loc 2 243 0
 1484 0036 022B     		cmp	r3, #2
 1485 0038 79D9     		bls	.L123
 244:libcanard/drivers/stm32/canard_stm32.h ****         {
 245:libcanard/drivers/stm32/canard_stm32.h ****             return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;          // No solution
 246:libcanard/drivers/stm32/canard_stm32.h ****         }
 247:libcanard/drivers/stm32/canard_stm32.h ****         bs1_bs2_sum--;
 1486              		.loc 2 247 0
 1487 003a 013B     		subs	r3, r3, #1
 1488              	.LVL143:
 1489 003c DBB2     		uxtb	r3, r3
ARM GAS  /tmp/cc1kQXNP.s 			page 40


 1490              	.LVL144:
 1491 003e F4E7     		b	.L111
 1492              	.L129:
 248:libcanard/drivers/stm32/canard_stm32.h ****     }
 249:libcanard/drivers/stm32/canard_stm32.h **** 
 250:libcanard/drivers/stm32/canard_stm32.h ****     const uint32_t prescaler = prescaler_bs / (1U + bs1_bs2_sum);
 1493              		.loc 2 250 0
 1494 0040 B4FBF1F1 		udiv	r1, r4, r1
 1495              	.LVL145:
 251:libcanard/drivers/stm32/canard_stm32.h ****     if ((prescaler < 1U) || (prescaler > 1024U))
 1496              		.loc 2 251 0
 1497 0044 4A1E     		subs	r2, r1, #1
 1498 0046 B2F5806F 		cmp	r2, #1024
 1499 004a 72D2     		bcs	.L124
 252:libcanard/drivers/stm32/canard_stm32.h ****     {
 253:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;              // No solution
 254:libcanard/drivers/stm32/canard_stm32.h ****     }
 255:libcanard/drivers/stm32/canard_stm32.h **** 
 256:libcanard/drivers/stm32/canard_stm32.h ****     /*
 257:libcanard/drivers/stm32/canard_stm32.h ****      * Now we have a constraint: (BS1 + BS2) == bs1_bs2_sum.
 258:libcanard/drivers/stm32/canard_stm32.h ****      * We need to find such values so that the sample point is as close as possible to the optimal 
 259:libcanard/drivers/stm32/canard_stm32.h ****      * which is 87.5%, which is 7/8.
 260:libcanard/drivers/stm32/canard_stm32.h ****      *
 261:libcanard/drivers/stm32/canard_stm32.h ****      *   Solve[(1 + bs1)/(1 + bs1 + bs2) == 7/8, bs2]  (* Where 7/8 is 0.875, the recommended sampl
 262:libcanard/drivers/stm32/canard_stm32.h ****      *   {{bs2 -> (1 + bs1)/7}}
 263:libcanard/drivers/stm32/canard_stm32.h ****      *
 264:libcanard/drivers/stm32/canard_stm32.h ****      * Hence:
 265:libcanard/drivers/stm32/canard_stm32.h ****      *   bs2 = (1 + bs1) / 7
 266:libcanard/drivers/stm32/canard_stm32.h ****      *   bs1 = (7 * bs1_bs2_sum - 1) / 8
 267:libcanard/drivers/stm32/canard_stm32.h ****      *
 268:libcanard/drivers/stm32/canard_stm32.h ****      * Sample point location can be computed as follows:
 269:libcanard/drivers/stm32/canard_stm32.h ****      *   Sample point location = (1 + bs1) / (1 + bs1 + bs2)
 270:libcanard/drivers/stm32/canard_stm32.h ****      *
 271:libcanard/drivers/stm32/canard_stm32.h ****      * Since the optimal solution is so close to the maximum, we prepare two solutions, and then pi
 272:libcanard/drivers/stm32/canard_stm32.h ****      *   - With rounding to nearest
 273:libcanard/drivers/stm32/canard_stm32.h ****      *   - With rounding to zero
 274:libcanard/drivers/stm32/canard_stm32.h ****      */
 275:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs1 = (uint8_t)(((7 * bs1_bs2_sum - 1) + 4) / 8);       // Trying rounding to nearest f
 1500              		.loc 2 275 0
 1501 004c C3EBC306 		rsb	r6, r3, r3, lsl #3
 1502 0050 F21C     		adds	r2, r6, #3
 1503 0052 22D4     		bmi	.L130
 1504              	.L114:
 1505 0054 D210     		asrs	r2, r2, #3
 1506 0056 D5B2     		uxtb	r5, r2
 1507              	.LVL146:
 276:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs2 = (uint8_t)(bs1_bs2_sum - bs1);  // NOLINT
 1508              		.loc 2 276 0
 1509 0058 5F1B     		subs	r7, r3, r5
 1510 005a FFB2     		uxtb	r7, r7
 1511              	.LVL147:
 277:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(bs1_bs2_sum > bs1);
 1512              		.loc 2 277 0
 1513 005c AB42     		cmp	r3, r5
 1514 005e 1ED9     		bls	.L131
 1515              	.LBB28:
 278:libcanard/drivers/stm32/canard_stm32.h **** 
ARM GAS  /tmp/cc1kQXNP.s 			page 41


 279:libcanard/drivers/stm32/canard_stm32.h ****     {
 280:libcanard/drivers/stm32/canard_stm32.h ****         const uint16_t sample_point_permill = (uint16_t)(1000U * (1U + bs1) / (1U + bs1 + bs2));  /
 1516              		.loc 2 280 0
 1517 0060 D2B2     		uxtb	r2, r2
 1518 0062 4FF47A74 		mov	r4, #1000
 1519              	.LVL148:
 1520 0066 02FB0444 		mla	r4, r2, r4, r4
 1521 006a 3A44     		add	r2, r2, r7
 1522 006c 0132     		adds	r2, r2, #1
 1523 006e B4FBF2F2 		udiv	r2, r4, r2
 1524 0072 92B2     		uxth	r2, r2
 1525              	.LVL149:
 281:libcanard/drivers/stm32/canard_stm32.h **** 
 282:libcanard/drivers/stm32/canard_stm32.h ****         if (sample_point_permill > MaxSamplePointLocationPermill)   // Strictly more!
 1526              		.loc 2 282 0
 1527 0074 B2F5617F 		cmp	r2, #900
 1528 0078 05D9     		bls	.L116
 283:libcanard/drivers/stm32/canard_stm32.h ****         {
 284:libcanard/drivers/stm32/canard_stm32.h ****             bs1 = (uint8_t)((7 * bs1_bs2_sum - 1) / 8);             // Nope, too far; now rounding 
 1529              		.loc 2 284 0
 1530 007a 751E     		subs	r5, r6, #1
 1531              	.LVL150:
 1532 007c 16D4     		bmi	.L132
 1533              	.L117:
 1534 007e C5F3C705 		ubfx	r5, r5, #3, #8
 1535              	.LVL151:
 285:libcanard/drivers/stm32/canard_stm32.h ****             bs2 = (uint8_t)(bs1_bs2_sum - bs1);
 1536              		.loc 2 285 0
 1537 0082 5B1B     		subs	r3, r3, r5
 1538              	.LVL152:
 1539 0084 DFB2     		uxtb	r7, r3
 1540              	.LVL153:
 1541              	.L116:
 1542              	.LBE28:
 286:libcanard/drivers/stm32/canard_stm32.h ****         }
 287:libcanard/drivers/stm32/canard_stm32.h ****     }
 288:libcanard/drivers/stm32/canard_stm32.h **** 
 289:libcanard/drivers/stm32/canard_stm32.h ****     const bool valid = (bs1 >= 1) && (bs1 <= MaxBS1) && (bs2 >= 1) && (bs2 <= MaxBS2);
 1543              		.loc 2 289 0
 1544 0086 6B1E     		subs	r3, r5, #1
 1545 0088 DBB2     		uxtb	r3, r3
 1546 008a 0F2B     		cmp	r3, #15
 1547 008c 10D8     		bhi	.L125
 1548 008e 002F     		cmp	r7, #0
 1549 0090 42D0     		beq	.L126
 1550 0092 082F     		cmp	r7, #8
 1551 0094 42D9     		bls	.L127
 1552 0096 0022     		movs	r2, #0
 1553              	.LVL154:
 1554 0098 0BE0     		b	.L118
 1555              	.LVL155:
 1556              	.L130:
 275:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs2 = (uint8_t)(bs1_bs2_sum - bs1);  // NOLINT
 1557              		.loc 2 275 0
 1558 009a 0732     		adds	r2, r2, #7
 1559 009c DAE7     		b	.L114
 1560              	.LVL156:
ARM GAS  /tmp/cc1kQXNP.s 			page 42


 1561              	.L131:
 277:libcanard/drivers/stm32/canard_stm32.h **** 
 1562              		.loc 2 277 0
 1563 009e 294B     		ldr	r3, .L133+12
 1564              	.LVL157:
 1565 00a0 294A     		ldr	r2, .L133+16
 1566 00a2 40F21511 		movw	r1, #277
 1567              	.LVL158:
 1568 00a6 2948     		ldr	r0, .L133+20
 1569              	.LVL159:
 1570 00a8 FFF7FEFF 		bl	__assert_func
 1571              	.LVL160:
 1572              	.L132:
 1573              	.LBB29:
 284:libcanard/drivers/stm32/canard_stm32.h ****             bs2 = (uint8_t)(bs1_bs2_sum - bs1);
 1574              		.loc 2 284 0
 1575 00ac 0735     		adds	r5, r5, #7
 1576 00ae E6E7     		b	.L117
 1577              	.LVL161:
 1578              	.L125:
 1579              	.LBE29:
 1580              		.loc 2 289 0
 1581 00b0 0022     		movs	r2, #0
 1582              	.LVL162:
 1583              	.L118:
 290:libcanard/drivers/stm32/canard_stm32.h **** 
 291:libcanard/drivers/stm32/canard_stm32.h ****     /*
 292:libcanard/drivers/stm32/canard_stm32.h ****      * Final validation
 293:libcanard/drivers/stm32/canard_stm32.h ****      * Helpful Python:
 294:libcanard/drivers/stm32/canard_stm32.h ****      * def sample_point_from_btr(x):
 295:libcanard/drivers/stm32/canard_stm32.h ****      *     assert 0b0011110010000000111111000000000 & x == 0
 296:libcanard/drivers/stm32/canard_stm32.h ****      *     ts2,ts1,brp = (x>>20)&7, (x>>16)&15, x&511
 297:libcanard/drivers/stm32/canard_stm32.h ****      *     return (1+ts1+1)/(1+ts1+1+ts2+1)
 298:libcanard/drivers/stm32/canard_stm32.h ****      */
 299:libcanard/drivers/stm32/canard_stm32.h ****     if ((target_bitrate != (peripheral_clock_rate / (prescaler * (1U + bs1 + bs2)))) ||
 1584              		.loc 2 299 0
 1585 00b2 EB19     		adds	r3, r5, r7
 1586 00b4 03FB0113 		mla	r3, r3, r1, r1
 1587 00b8 B0FBF3F0 		udiv	r0, r0, r3
 1588              	.LVL163:
 1589 00bc 244B     		ldr	r3, .L133+24
 1590 00be 9842     		cmp	r0, r3
 1591 00c0 2ED1     		bne	.L119
 1592 00c2 6AB3     		cbz	r2, .L119
 300:libcanard/drivers/stm32/canard_stm32.h ****         !valid)
 301:libcanard/drivers/stm32/canard_stm32.h ****     {
 302:libcanard/drivers/stm32/canard_stm32.h ****         // This actually means that the algorithm has a logic error, hence assert(0).
 303:libcanard/drivers/stm32/canard_stm32.h ****         CANARD_ASSERT(0);  // NOLINT
 304:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 305:libcanard/drivers/stm32/canard_stm32.h ****     }
 306:libcanard/drivers/stm32/canard_stm32.h **** 
 307:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_rate_prescaler = (uint16_t) prescaler;
 1593              		.loc 2 307 0
 1594 00c4 ADF80810 		strh	r1, [sp, #8]	@ movhi
 308:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->max_resynchronization_jump_width = 1;      // One is recommended by UAVCAN, CANOpe
 1595              		.loc 2 308 0
 1596 00c8 0123     		movs	r3, #1
ARM GAS  /tmp/cc1kQXNP.s 			page 43


 1597 00ca 8DF80C30 		strb	r3, [sp, #12]
 309:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_segment_1 = bs1;
 1598              		.loc 2 309 0
 1599 00ce 8DF80A50 		strb	r5, [sp, #10]
 310:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_segment_2 = bs2;
 1600              		.loc 2 310 0
 1601 00d2 8DF80B70 		strb	r7, [sp, #11]
 311:libcanard/drivers/stm32/canard_stm32.h **** 
 312:libcanard/drivers/stm32/canard_stm32.h ****     return 0;
 1602              		.loc 2 312 0
 1603 00d6 0023     		movs	r3, #0
 1604              	.LVL164:
 1605              	.L112:
 1606              	.LBE27:
 1607              	.LBE26:
 103:Src/uavcan.c  ****     {
 1608              		.loc 1 103 0
 1609 00d8 03B1     		cbz	r3, .L121
 105:Src/uavcan.c  ****     }
 1610              		.loc 1 105 0
 1611              		.syntax unified
 1612              	@ 105 "Src/uavcan.c" 1
 1613 00da 01BE     		BKPT #01
 1614              	@ 0 "" 2
 1615              		.thumb
 1616              		.syntax unified
 1617              	.L121:
 107:Src/uavcan.c  ****     if (result)
 1618              		.loc 1 107 0
 1619 00dc 0021     		movs	r1, #0
 1620 00de 02A8     		add	r0, sp, #8
 1621 00e0 FFF7FEFF 		bl	canardSTM32Init
 1622              	.LVL165:
 108:Src/uavcan.c  ****     {
 1623              		.loc 1 108 0
 1624 00e4 00B1     		cbz	r0, .L122
 110:Src/uavcan.c  ****     }
 1625              		.loc 1 110 0
 1626              		.syntax unified
 1627              	@ 110 "Src/uavcan.c" 1
 1628 00e6 01BE     		BKPT #01
 1629              	@ 0 "" 2
 1630              		.thumb
 1631              		.syntax unified
 1632              	.L122:
 113:Src/uavcan.c  ****                g_canard_memory_pool,              // Raw memory chunk used for dynamic allocation
 1633              		.loc 1 113 0
 1634 00e8 1A4C     		ldr	r4, .L133+28
 1635 00ea 0023     		movs	r3, #0
 1636 00ec 0193     		str	r3, [sp, #4]
 1637 00ee 1A4B     		ldr	r3, .L133+32
 1638 00f0 0093     		str	r3, [sp]
 1639 00f2 1A4B     		ldr	r3, .L133+36
 1640 00f4 4FF48062 		mov	r2, #1024
 1641 00f8 1949     		ldr	r1, .L133+40
 1642 00fa 2046     		mov	r0, r4
 1643              	.LVL166:
ARM GAS  /tmp/cc1kQXNP.s 			page 44


 1644 00fc FFF7FEFF 		bl	canardInit
 1645              	.LVL167:
 120:Src/uavcan.c  ****     HAL_GPIO_WritePin(LedPort,LedRed,LedOff);
 1646              		.loc 1 120 0
 1647 0100 0E4B     		ldr	r3, .L133+4
 1648 0102 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 1649 0104 2046     		mov	r0, r4
 1650 0106 FFF7FEFF 		bl	canardSetLocalNodeID
 1651              	.LVL168:
 121:Src/uavcan.c  ****  
 1652              		.loc 1 121 0
 1653 010a 0122     		movs	r2, #1
 1654 010c 1021     		movs	r1, #16
 1655 010e 1548     		ldr	r0, .L133+44
 1656 0110 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1657              	.LVL169:
 124:Src/uavcan.c  **** 
 1658              		.loc 1 124 0
 1659 0114 05B0     		add	sp, sp, #20
 1660              	.LCFI32:
 1661              		.cfi_remember_state
 1662              		.cfi_def_cfa_offset 20
 1663              		@ sp needed
 1664 0116 F0BD     		pop	{r4, r5, r6, r7, pc}
 1665              	.LVL170:
 1666              	.L126:
 1667              	.LCFI33:
 1668              		.cfi_restore_state
 1669              	.LBB31:
 1670              	.LBB30:
 289:libcanard/drivers/stm32/canard_stm32.h **** 
 1671              		.loc 2 289 0
 1672 0118 0022     		movs	r2, #0
 1673              	.LVL171:
 1674 011a CAE7     		b	.L118
 1675              	.LVL172:
 1676              	.L127:
 1677 011c 0122     		movs	r2, #1
 1678              	.LVL173:
 1679 011e C8E7     		b	.L118
 1680              	.LVL174:
 1681              	.L119:
 303:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 1682              		.loc 2 303 0
 1683 0120 114B     		ldr	r3, .L133+48
 1684 0122 094A     		ldr	r2, .L133+16
 1685              	.LVL175:
 1686 0124 40F22F11 		movw	r1, #303
 1687              	.LVL176:
 1688 0128 0848     		ldr	r0, .L133+20
 1689 012a FFF7FEFF 		bl	__assert_func
 1690              	.LVL177:
 1691              	.L123:
 245:libcanard/drivers/stm32/canard_stm32.h ****         }
 1692              		.loc 2 245 0
 1693 012e 0F4B     		ldr	r3, .L133+52
 1694              	.LVL178:
ARM GAS  /tmp/cc1kQXNP.s 			page 45


 1695 0130 D2E7     		b	.L112
 1696              	.LVL179:
 1697              	.L124:
 253:libcanard/drivers/stm32/canard_stm32.h ****     }
 1698              		.loc 2 253 0
 1699 0132 0E4B     		ldr	r3, .L133+52
 1700              	.LVL180:
 1701 0134 D0E7     		b	.L112
 1702              	.L134:
 1703 0136 00BF     		.align	2
 1704              	.L133:
 1705 0138 00000000 		.word	.LANCHOR5
 1706 013c 00000000 		.word	.LANCHOR7
 1707 0140 83DE1B43 		.word	1125899907
 1708 0144 00000000 		.word	.LC2
 1709 0148 00000000 		.word	.LANCHOR8
 1710 014c 14000000 		.word	.LC3
 1711 0150 40420F00 		.word	1000000
 1712 0154 00000000 		.word	.LANCHOR0
 1713 0158 00000000 		.word	shouldAcceptTransfer
 1714 015c 00000000 		.word	onTransferReceived
 1715 0160 00000000 		.word	g_canard_memory_pool
 1716 0164 000C0140 		.word	1073810432
 1717 0168 3C000000 		.word	.LC4
 1718 016c 18FCFFFF 		.word	-1000
 1719              	.LBE30:
 1720              	.LBE31:
 1721              		.cfi_endproc
 1722              	.LFE70:
 1724              		.section	.text.signalTag,"ax",%progbits
 1725              		.align	1
 1726              		.global	signalTag
 1727              		.syntax unified
 1728              		.thumb
 1729              		.thumb_func
 1730              		.fpu softvfp
 1732              	signalTag:
 1733              	.LFB88:
 413:Src/uavcan.c  **** 
 414:Src/uavcan.c  **** 
 415:Src/uavcan.c  **** bool signalTag(uint16_t transfer)
 416:Src/uavcan.c  **** {   
 1734              		.loc 1 416 0
 1735              		.cfi_startproc
 1736              		@ args = 0, pretend = 0, frame = 0
 1737              		@ frame_needed = 0, uses_anonymous_args = 0
 1738              	.LVL181:
 1739 0000 10B5     		push	{r4, lr}
 1740              	.LCFI34:
 1741              		.cfi_def_cfa_offset 8
 1742              		.cfi_offset 4, -8
 1743              		.cfi_offset 14, -4
 1744 0002 0446     		mov	r4, r0
 417:Src/uavcan.c  ****     static uint16_t rxTag=0;
 418:Src/uavcan.c  ****     static uint32_t signal_time = 0;
 419:Src/uavcan.c  ****     if(HAL_GetTick() < signal_time + SIGNALTEST_PERIOD_mS) {return;} // rate limiting
 1745              		.loc 1 419 0
ARM GAS  /tmp/cc1kQXNP.s 			page 46


 1746 0004 FFF7FEFF 		bl	HAL_GetTick
 1747              	.LVL182:
 1748 0008 124B     		ldr	r3, .L142
 1749 000a 1B68     		ldr	r3, [r3]
 1750 000c 03F57A73 		add	r3, r3, #1000
 1751 0010 9842     		cmp	r0, r3
 1752 0012 00D2     		bcs	.L140
 1753              	.L135:
 420:Src/uavcan.c  ****     signal_time = HAL_GetTick();
 421:Src/uavcan.c  **** 
 422:Src/uavcan.c  ****     if(transfer==rxTag)
 423:Src/uavcan.c  ****     {
 424:Src/uavcan.c  ****         HAL_UART_Transmit(&huart1,"no",2,0xffff);
 425:Src/uavcan.c  ****         rawcommandTag=true;
 426:Src/uavcan.c  ****         //HAL_GPIO_WritePin(LedPort,LedRed,LedOff);
 427:Src/uavcan.c  ****         return true;
 428:Src/uavcan.c  ****     }   
 429:Src/uavcan.c  ****     else
 430:Src/uavcan.c  ****     {   
 431:Src/uavcan.c  ****         rxTag=transfer;
 432:Src/uavcan.c  ****         HAL_UART_Transmit(&huart1,"ok",2,0xffff);
 433:Src/uavcan.c  ****         //HAL_GPIO_WritePin(LedPort,LedRed,LedOn);
 434:Src/uavcan.c  ****        // rawcommandTag=false;
 435:Src/uavcan.c  ****         return false;
 436:Src/uavcan.c  **** 
 437:Src/uavcan.c  ****     }
 438:Src/uavcan.c  **** }
 1754              		.loc 1 438 0
 1755 0014 10BD     		pop	{r4, pc}
 1756              	.L140:
 420:Src/uavcan.c  ****     signal_time = HAL_GetTick();
 1757              		.loc 1 420 0
 1758 0016 FFF7FEFF 		bl	HAL_GetTick
 1759              	.LVL183:
 1760 001a 0E4B     		ldr	r3, .L142
 1761 001c 1860     		str	r0, [r3]
 422:Src/uavcan.c  ****     {
 1762              		.loc 1 422 0
 1763 001e 0E4B     		ldr	r3, .L142+4
 1764 0020 1B88     		ldrh	r3, [r3]
 1765 0022 A342     		cmp	r3, r4
 1766 0024 0AD0     		beq	.L141
 431:Src/uavcan.c  ****         HAL_UART_Transmit(&huart1,"ok",2,0xffff);
 1767              		.loc 1 431 0
 1768 0026 0C4B     		ldr	r3, .L142+4
 1769 0028 1C80     		strh	r4, [r3]	@ movhi
 432:Src/uavcan.c  ****         //HAL_GPIO_WritePin(LedPort,LedRed,LedOn);
 1770              		.loc 1 432 0
 1771 002a 4FF6FF73 		movw	r3, #65535
 1772 002e 0222     		movs	r2, #2
 1773 0030 0A49     		ldr	r1, .L142+8
 1774 0032 0B48     		ldr	r0, .L142+12
 1775 0034 FFF7FEFF 		bl	HAL_UART_Transmit
 1776              	.LVL184:
 435:Src/uavcan.c  **** 
 1777              		.loc 1 435 0
 1778 0038 0020     		movs	r0, #0
ARM GAS  /tmp/cc1kQXNP.s 			page 47


 1779 003a EBE7     		b	.L135
 1780              	.L141:
 424:Src/uavcan.c  ****         rawcommandTag=true;
 1781              		.loc 1 424 0
 1782 003c 4FF6FF73 		movw	r3, #65535
 1783 0040 0222     		movs	r2, #2
 1784 0042 0849     		ldr	r1, .L142+16
 1785 0044 0648     		ldr	r0, .L142+12
 1786 0046 FFF7FEFF 		bl	HAL_UART_Transmit
 1787              	.LVL185:
 425:Src/uavcan.c  ****         //HAL_GPIO_WritePin(LedPort,LedRed,LedOff);
 1788              		.loc 1 425 0
 1789 004a 0120     		movs	r0, #1
 1790 004c 064B     		ldr	r3, .L142+20
 1791 004e 1870     		strb	r0, [r3]
 427:Src/uavcan.c  ****     }   
 1792              		.loc 1 427 0
 1793 0050 E0E7     		b	.L135
 1794              	.L143:
 1795 0052 00BF     		.align	2
 1796              	.L142:
 1797 0054 00000000 		.word	.LANCHOR9
 1798 0058 00000000 		.word	.LANCHOR10
 1799 005c 04000000 		.word	.LC6
 1800 0060 00000000 		.word	huart1
 1801 0064 00000000 		.word	.LC5
 1802 0068 00000000 		.word	.LANCHOR11
 1803              		.cfi_endproc
 1804              	.LFE88:
 1806              		.section	.text.receiveCanard,"ax",%progbits
 1807              		.align	1
 1808              		.global	receiveCanard
 1809              		.syntax unified
 1810              		.thumb
 1811              		.thumb_func
 1812              		.fpu softvfp
 1814              	receiveCanard:
 1815              	.LFB72:
 145:Src/uavcan.c  ****     CanardCANFrame rx_frame;
 1816              		.loc 1 145 0
 1817              		.cfi_startproc
 1818              		@ args = 0, pretend = 0, frame = 16
 1819              		@ frame_needed = 0, uses_anonymous_args = 0
 1820 0000 00B5     		push	{lr}
 1821              	.LCFI35:
 1822              		.cfi_def_cfa_offset 4
 1823              		.cfi_offset 14, -4
 1824 0002 85B0     		sub	sp, sp, #20
 1825              	.LCFI36:
 1826              		.cfi_def_cfa_offset 24
 147:Src/uavcan.c  ****     if(res)
 1827              		.loc 1 147 0
 1828 0004 6846     		mov	r0, sp
 1829 0006 FFF7FEFF 		bl	canardSTM32Receive
 1830              	.LVL186:
 148:Src/uavcan.c  ****     {
 1831              		.loc 1 148 0
ARM GAS  /tmp/cc1kQXNP.s 			page 48


 1832 000a 30B9     		cbnz	r0, .L147
 1833              	.LVL187:
 1834              	.L145:
 152:Src/uavcan.c  **** 
 1835              		.loc 1 152 0
 1836 000c 094B     		ldr	r3, .L148
 1837 000e 1888     		ldrh	r0, [r3]
 1838 0010 FFF7FEFF 		bl	signalTag
 1839              	.LVL188:
 154:Src/uavcan.c  **** 
 1840              		.loc 1 154 0
 1841 0014 05B0     		add	sp, sp, #20
 1842              	.LCFI37:
 1843              		.cfi_remember_state
 1844              		.cfi_def_cfa_offset 4
 1845              		@ sp needed
 1846 0016 5DF804FB 		ldr	pc, [sp], #4
 1847              	.LVL189:
 1848              	.L147:
 1849              	.LCFI38:
 1850              		.cfi_restore_state
 150:Src/uavcan.c  ****     }    
 1851              		.loc 1 150 0
 1852 001a FFF7FEFF 		bl	HAL_GetTick
 1853              	.LVL190:
 1854 001e 4FF47A72 		mov	r2, #1000
 1855 0022 02FB00F2 		mul	r2, r2, r0
 1856 0026 0023     		movs	r3, #0
 1857 0028 6946     		mov	r1, sp
 1858 002a 0348     		ldr	r0, .L148+4
 1859 002c FFF7FEFF 		bl	canardHandleRxFrame
 1860              	.LVL191:
 1861 0030 ECE7     		b	.L145
 1862              	.L149:
 1863 0032 00BF     		.align	2
 1864              	.L148:
 1865 0034 00000000 		.word	.LANCHOR4
 1866 0038 00000000 		.word	.LANCHOR0
 1867              		.cfi_endproc
 1868              	.LFE72:
 1870              		.section	.text.ledStatus,"ax",%progbits
 1871              		.align	1
 1872              		.global	ledStatus
 1873              		.syntax unified
 1874              		.thumb
 1875              		.thumb_func
 1876              		.fpu softvfp
 1878              	ledStatus:
 1879              	.LFB84:
 376:Src/uavcan.c  ****   signalTag(rawcommandTransfer);
 1880              		.loc 1 376 0
 1881              		.cfi_startproc
 1882              		@ args = 0, pretend = 0, frame = 0
 1883              		@ frame_needed = 0, uses_anonymous_args = 0
 1884 0000 08B5     		push	{r3, lr}
 1885              	.LCFI39:
 1886              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/cc1kQXNP.s 			page 49


 1887              		.cfi_offset 3, -8
 1888              		.cfi_offset 14, -4
 377:Src/uavcan.c  **** }
 1889              		.loc 1 377 0
 1890 0002 024B     		ldr	r3, .L152
 1891 0004 1888     		ldrh	r0, [r3]
 1892 0006 FFF7FEFF 		bl	signalTag
 1893              	.LVL192:
 378:Src/uavcan.c  **** 
 1894              		.loc 1 378 0
 1895 000a 08BD     		pop	{r3, pc}
 1896              	.L153:
 1897              		.align	2
 1898              	.L152:
 1899 000c 00000000 		.word	.LANCHOR4
 1900              		.cfi_endproc
 1901              	.LFE84:
 1903              		.section	.text.led,"ax",%progbits
 1904              		.align	1
 1905              		.global	led
 1906              		.syntax unified
 1907              		.thumb
 1908              		.thumb_func
 1909              		.fpu softvfp
 1911              	led:
 1912              	.LFB89:
 439:Src/uavcan.c  **** 
 440:Src/uavcan.c  **** 
 441:Src/uavcan.c  **** void led()
 442:Src/uavcan.c  **** {
 1913              		.loc 1 442 0
 1914              		.cfi_startproc
 1915              		@ args = 0, pretend = 0, frame = 0
 1916              		@ frame_needed = 0, uses_anonymous_args = 0
 1917 0000 08B5     		push	{r3, lr}
 1918              	.LCFI40:
 1919              		.cfi_def_cfa_offset 8
 1920              		.cfi_offset 3, -8
 1921              		.cfi_offset 14, -4
 443:Src/uavcan.c  ****     static uint32_t led_time = 0;
 444:Src/uavcan.c  ****     if(HAL_GetTick() < led_time + SIGNALTEST_PERIOD_mS) {return;} // rate limiting
 1922              		.loc 1 444 0
 1923 0002 FFF7FEFF 		bl	HAL_GetTick
 1924              	.LVL193:
 1925 0006 0C4B     		ldr	r3, .L160
 1926 0008 1B68     		ldr	r3, [r3]
 1927 000a 03F57A73 		add	r3, r3, #1000
 1928 000e 9842     		cmp	r0, r3
 1929 0010 00D2     		bcs	.L158
 1930              	.L154:
 445:Src/uavcan.c  ****     led_time = HAL_GetTick();
 446:Src/uavcan.c  ****     if(rawcommandTag)
 447:Src/uavcan.c  ****     {
 448:Src/uavcan.c  ****         HAL_GPIO_TogglePin(LedPort,LedRed);
 449:Src/uavcan.c  ****     }
 450:Src/uavcan.c  ****     else
 451:Src/uavcan.c  ****     {
ARM GAS  /tmp/cc1kQXNP.s 			page 50


 452:Src/uavcan.c  ****         HAL_GPIO_WritePin(LedPort,LedRed,LedOn);
 453:Src/uavcan.c  ****     }  
 454:Src/uavcan.c  **** }
 1931              		.loc 1 454 0
 1932 0012 08BD     		pop	{r3, pc}
 1933              	.L158:
 445:Src/uavcan.c  ****     led_time = HAL_GetTick();
 1934              		.loc 1 445 0
 1935 0014 FFF7FEFF 		bl	HAL_GetTick
 1936              	.LVL194:
 1937 0018 074B     		ldr	r3, .L160
 1938 001a 1860     		str	r0, [r3]
 446:Src/uavcan.c  ****     {
 1939              		.loc 1 446 0
 1940 001c 074B     		ldr	r3, .L160+4
 1941 001e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1942 0020 2BB9     		cbnz	r3, .L159
 452:Src/uavcan.c  ****     }  
 1943              		.loc 1 452 0
 1944 0022 0022     		movs	r2, #0
 1945 0024 1021     		movs	r1, #16
 1946 0026 0648     		ldr	r0, .L160+8
 1947 0028 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1948              	.LVL195:
 1949 002c F1E7     		b	.L154
 1950              	.L159:
 448:Src/uavcan.c  ****     }
 1951              		.loc 1 448 0
 1952 002e 1021     		movs	r1, #16
 1953 0030 0348     		ldr	r0, .L160+8
 1954 0032 FFF7FEFF 		bl	HAL_GPIO_TogglePin
 1955              	.LVL196:
 1956 0036 ECE7     		b	.L154
 1957              	.L161:
 1958              		.align	2
 1959              	.L160:
 1960 0038 00000000 		.word	.LANCHOR12
 1961 003c 00000000 		.word	.LANCHOR11
 1962 0040 000C0140 		.word	1073810432
 1963              		.cfi_endproc
 1964              	.LFE89:
 1966              		.global	parameters
 1967              		.global	g_uptime
 1968              		.global	FlashAddress
 1969              		.comm	FlashData,8,4
 1970              		.global	rawcommandTransfer
 1971              		.comm	g_canard_memory_pool,1024,4
 1972              		.comm	OutIndex,1,1
 1973              		.comm	LedStatus,1,1
 1974              		.global	nodeID
 1975              		.global	rawcommandTag
 1976              		.section	.bss.g_canard,"aw",%nobits
 1977              		.align	2
 1978              		.set	.LANCHOR0,. + 0
 1981              	g_canard:
 1982 0000 00000000 		.space	36
 1982      00000000 
ARM GAS  /tmp/cc1kQXNP.s 			page 51


 1982      00000000 
 1982      00000000 
 1982      00000000 
 1983              		.section	.bss.g_uptime,"aw",%nobits
 1984              		.align	2
 1987              	g_uptime:
 1988 0000 00000000 		.space	4
 1989              		.section	.bss.led_time.8078,"aw",%nobits
 1990              		.align	2
 1991              		.set	.LANCHOR12,. + 0
 1994              	led_time.8078:
 1995 0000 00000000 		.space	4
 1996              		.section	.bss.publish_time.7999,"aw",%nobits
 1997              		.align	2
 1998              		.set	.LANCHOR1,. + 0
 2001              	publish_time.7999:
 2002 0000 00000000 		.space	4
 2003              		.section	.bss.rawcommandTag,"aw",%nobits
 2004              		.set	.LANCHOR11,. + 0
 2007              	rawcommandTag:
 2008 0000 00       		.space	1
 2009              		.section	.bss.rawcommandTransfer,"aw",%nobits
 2010              		.align	1
 2011              		.set	.LANCHOR4,. + 0
 2014              	rawcommandTransfer:
 2015 0000 0000     		.space	2
 2016              		.section	.bss.rxTag.8074,"aw",%nobits
 2017              		.align	1
 2018              		.set	.LANCHOR10,. + 0
 2021              	rxTag.8074:
 2022 0000 0000     		.space	2
 2023              		.section	.bss.signal_time.8075,"aw",%nobits
 2024              		.align	2
 2025              		.set	.LANCHOR9,. + 0
 2028              	signal_time.8075:
 2029 0000 00000000 		.space	4
 2030              		.section	.bss.spin_time.7991,"aw",%nobits
 2031              		.align	2
 2032              		.set	.LANCHOR2,. + 0
 2035              	spin_time.7991:
 2036 0000 00000000 		.space	4
 2037              		.section	.bss.transfer_id.7993,"aw",%nobits
 2038              		.set	.LANCHOR3,. + 0
 2041              	transfer_id.7993:
 2042 0000 00       		.space	1
 2043              		.section	.data.FlashAddress,"aw",%progbits
 2044              		.align	2
 2045              		.set	.LANCHOR6,. + 0
 2048              	FlashAddress:
 2049 0000 00F00008 		.word	134279168
 2050              		.section	.data.nodeID,"aw",%progbits
 2051              		.set	.LANCHOR7,. + 0
 2054              	nodeID:
 2055 0000 0A       		.byte	10
 2056              		.section	.data.parameters,"aw",%progbits
 2057              		.align	3
 2058              		.set	.LANCHOR5,. + 0
ARM GAS  /tmp/cc1kQXNP.s 			page 52


 2061              	parameters:
 2062 0000 00000000 		.word	.LC7
 2063 0004 00000000 		.space	4
 2064 0008 00000000 		.word	0
 2065 000c 00000000 		.word	0
 2066 0010 00000000 		.word	0
 2067 0014 00000000 		.word	0
 2068 0018 64000000 		.word	100
 2069 001c 00000000 		.word	0
 2070 0020 00000000 		.word	0
 2071 0024 00000000 		.word	0
 2072 0028 08000000 		.word	.LC8
 2073 002c 00000000 		.space	4
 2074 0030 00000000 		.word	0
 2075 0034 00000000 		.word	0
 2076 0038 05000000 		.word	5
 2077 003c 00000000 		.word	0
 2078 0040 64000000 		.word	100
 2079 0044 00000000 		.word	0
 2080 0048 0A000000 		.word	10
 2081 004c 00000000 		.word	0
 2082 0050 14000000 		.word	.LC9
 2083 0054 00000000 		.space	4
 2084 0058 00000000 		.word	0
 2085 005c 00000000 		.word	0
 2086 0060 00000000 		.word	0
 2087 0064 00000000 		.word	0
 2088 0068 14000000 		.word	20
 2089 006c 00000000 		.word	0
 2090 0070 00000000 		.word	0
 2091 0074 00000000 		.word	0
 2092 0078 20000000 		.word	.LC10
 2093 007c 00000000 		.space	4
 2094 0080 00000000 		.word	0
 2095 0084 00000000 		.word	0
 2096 0088 EA010000 		.word	490
 2097 008c 00000000 		.word	0
 2098 0090 E8030000 		.word	1000
 2099 0094 00000000 		.word	0
 2100 0098 00000000 		.word	0
 2101 009c 00000000 		.word	0
 2102              		.section	.rodata.__func__.5968,"a",%progbits
 2103              		.align	2
 2104              		.set	.LANCHOR8,. + 0
 2107              	__func__.5968:
 2108 0000 63616E61 		.ascii	"canardSTM32ComputeCANTimings\000"
 2108      72645354 
 2108      4D333243 
 2108      6F6D7075 
 2108      74654341 
 2109              		.section	.rodata.getsetHandleCanard.str1.4,"aMS",%progbits,1
 2110              		.align	2
 2111              	.LC1:
 2112 0000 4F4B00   		.ascii	"OK\000"
 2113              		.section	.rodata.makeNodeInfoMessage.str1.4,"aMS",%progbits,1
 2114              		.align	2
 2115              	.LC0:
ARM GAS  /tmp/cc1kQXNP.s 			page 53


 2116 0000 736B7979 		.ascii	"skyyu.uavcan_actuator\000"
 2116      752E7561 
 2116      7663616E 
 2116      5F616374 
 2116      7561746F 
 2117              		.section	.rodata.signalTag.str1.4,"aMS",%progbits,1
 2118              		.align	2
 2119              	.LC5:
 2120 0000 6E6F00   		.ascii	"no\000"
 2121 0003 00       		.space	1
 2122              	.LC6:
 2123 0004 6F6B00   		.ascii	"ok\000"
 2124              		.section	.rodata.str1.4,"aMS",%progbits,1
 2125              		.align	2
 2126              	.LC7:
 2127 0000 4E6F6465 		.ascii	"NodeID\000"
 2127      494400
 2128 0007 00       		.space	1
 2129              	.LC8:
 2130 0008 53746174 		.ascii	"StatusRate\000"
 2130      75735261 
 2130      746500
 2131 0013 00       		.space	1
 2132              	.LC9:
 2133 0014 4F757449 		.ascii	"OutIndex\000"
 2133      6E646578 
 2133      00
 2134 001d 000000   		.space	3
 2135              	.LC10:
 2136 0020 50574D46 		.ascii	"PWMFrequency\000"
 2136      72657175 
 2136      656E6379 
 2136      00
 2137              		.section	.rodata.uavcanInit.str1.4,"aMS",%progbits,1
 2138              		.align	2
 2139              	.LC2:
 2140 0000 6273315F 		.ascii	"bs1_bs2_sum > bs1\000"
 2140      6273325F 
 2140      73756D20 
 2140      3E206273 
 2140      3100
 2141 0012 0000     		.space	2
 2142              	.LC3:
 2143 0014 6C696263 		.ascii	"libcanard/drivers/stm32/canard_stm32.h\000"
 2143      616E6172 
 2143      642F6472 
 2143      69766572 
 2143      732F7374 
 2144 003b 00       		.space	1
 2145              	.LC4:
 2146 003c 3000     		.ascii	"0\000"
 2147              		.text
 2148              	.Letext0:
 2149              		.file 3 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_default_types.h
 2150              		.file 4 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/stddef.h"
 2151              		.file 5 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 2152              		.file 6 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
ARM GAS  /tmp/cc1kQXNP.s 			page 54


 2153              		.file 7 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 2154              		.file 8 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 2155              		.file 9 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdlib.h"
 2156              		.file 10 "libcanard/canard.h"
 2157              		.file 11 "Drivers/CMSIS/Include/core_cm3.h"
 2158              		.file 12 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 2159              		.file 13 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 2160              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 2161              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 2162              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 2163              		.file 17 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_tim.h"
 2164              		.file 18 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 2165              		.file 19 "Src/uavcan.h"
 2166              		.file 20 "Src/tim.h"
 2167              		.file 21 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 2168              		.file 22 "Src/internalflash.h"
 2169              		.file 23 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/string.h"
 2170              		.file 24 "<built-in>"
 2171              		.file 25 "/usr/bin/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/assert.h"
 2172              		.file 26 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_rcc.h"
ARM GAS  /tmp/cc1kQXNP.s 			page 55


DEFINED SYMBOLS
                            *ABS*:0000000000000000 uavcan.c
     /tmp/cc1kQXNP.s:16     .text.shouldAcceptTransfer:0000000000000000 $t
     /tmp/cc1kQXNP.s:23     .text.shouldAcceptTransfer:0000000000000000 shouldAcceptTransfer
     /tmp/cc1kQXNP.s:88     .text.shouldAcceptTransfer:0000000000000048 $d
     /tmp/cc1kQXNP.s:98     .text.sendCanard:0000000000000000 $t
     /tmp/cc1kQXNP.s:105    .text.sendCanard:0000000000000000 sendCanard
     /tmp/cc1kQXNP.s:168    .text.sendCanard:000000000000002c $d
     /tmp/cc1kQXNP.s:173    .text.publishCanard:0000000000000000 $t
     /tmp/cc1kQXNP.s:180    .text.publishCanard:0000000000000000 publishCanard
     /tmp/cc1kQXNP.s:212    .text.publishCanard:000000000000001c $d
     /tmp/cc1kQXNP.s:217    .text.makeNodeStatusMessage:0000000000000000 $t
     /tmp/cc1kQXNP.s:224    .text.makeNodeStatusMessage:0000000000000000 makeNodeStatusMessage
     /tmp/cc1kQXNP.s:287    .text.makeNodeStatusMessage:0000000000000054 $d
     /tmp/cc1kQXNP.s:292    .text.spinCanard:0000000000000000 $t
     /tmp/cc1kQXNP.s:299    .text.spinCanard:0000000000000000 spinCanard
     /tmp/cc1kQXNP.s:361    .text.spinCanard:0000000000000050 $d
     /tmp/cc1kQXNP.s:370    .text.readUniqueID:0000000000000000 $t
     /tmp/cc1kQXNP.s:377    .text.readUniqueID:0000000000000000 readUniqueID
     /tmp/cc1kQXNP.s:409    .text.makeNodeInfoMessage:0000000000000000 $t
     /tmp/cc1kQXNP.s:416    .text.makeNodeInfoMessage:0000000000000000 makeNodeInfoMessage
     /tmp/cc1kQXNP.s:487    .text.makeNodeInfoMessage:0000000000000060 $d
     /tmp/cc1kQXNP.s:493    .text.getNodeInfoHandleCanard:0000000000000000 $t
     /tmp/cc1kQXNP.s:500    .text.getNodeInfoHandleCanard:0000000000000000 getNodeInfoHandleCanard
     /tmp/cc1kQXNP.s:558    .text.getNodeInfoHandleCanard:0000000000000040 $d
     /tmp/cc1kQXNP.s:565    .text.pwmUpdate:0000000000000000 $t
     /tmp/cc1kQXNP.s:572    .text.pwmUpdate:0000000000000000 pwmUpdate
     /tmp/cc1kQXNP.s:595    .text.pwmUpdate:0000000000000010 $d
     /tmp/cc1kQXNP.s:600    .text.rawcmdHandleCanard:0000000000000000 $t
     /tmp/cc1kQXNP.s:607    .text.rawcmdHandleCanard:0000000000000000 rawcmdHandleCanard
     /tmp/cc1kQXNP.s:669    .text.rawcmdHandleCanard:0000000000000044 $d
     /tmp/cc1kQXNP.s:675    .text.encodeParamCanard:0000000000000000 $t
     /tmp/cc1kQXNP.s:682    .text.encodeParamCanard:0000000000000000 encodeParamCanard
     /tmp/cc1kQXNP.s:884    .text.parametersLoad:0000000000000000 $t
     /tmp/cc1kQXNP.s:891    .text.parametersLoad:0000000000000000 parametersLoad
     /tmp/cc1kQXNP.s:932    .text.parametersLoad:0000000000000034 $d
                            *COM*:0000000000000008 FlashData
     /tmp/cc1kQXNP.s:939    .text.parametersSave:0000000000000000 $t
     /tmp/cc1kQXNP.s:946    .text.parametersSave:0000000000000000 parametersSave
     /tmp/cc1kQXNP.s:982    .text.parametersSave:0000000000000024 $d
     /tmp/cc1kQXNP.s:989    .text.getsetHandleCanard:0000000000000000 $t
     /tmp/cc1kQXNP.s:996    .text.getsetHandleCanard:0000000000000000 getsetHandleCanard
     /tmp/cc1kQXNP.s:1267   .text.getsetHandleCanard:0000000000000150 $d
     /tmp/cc1kQXNP.s:1279   .text.onTransferReceived:0000000000000000 $t
     /tmp/cc1kQXNP.s:1286   .text.onTransferReceived:0000000000000000 onTransferReceived
     /tmp/cc1kQXNP.s:1347   .text.parameterCheck:0000000000000000 $t
     /tmp/cc1kQXNP.s:1354   .text.parameterCheck:0000000000000000 parameterCheck
     /tmp/cc1kQXNP.s:1419   .text.parameterCheck:0000000000000070 $d
     /tmp/cc1kQXNP.s:1424   .text.uavcanInit:0000000000000000 $t
     /tmp/cc1kQXNP.s:1431   .text.uavcanInit:0000000000000000 uavcanInit
     /tmp/cc1kQXNP.s:1705   .text.uavcanInit:0000000000000138 $d
                            *COM*:0000000000000400 g_canard_memory_pool
     /tmp/cc1kQXNP.s:1725   .text.signalTag:0000000000000000 $t
     /tmp/cc1kQXNP.s:1732   .text.signalTag:0000000000000000 signalTag
     /tmp/cc1kQXNP.s:1797   .text.signalTag:0000000000000054 $d
     /tmp/cc1kQXNP.s:1807   .text.receiveCanard:0000000000000000 $t
     /tmp/cc1kQXNP.s:1814   .text.receiveCanard:0000000000000000 receiveCanard
ARM GAS  /tmp/cc1kQXNP.s 			page 56


     /tmp/cc1kQXNP.s:1865   .text.receiveCanard:0000000000000034 $d
     /tmp/cc1kQXNP.s:1871   .text.ledStatus:0000000000000000 $t
     /tmp/cc1kQXNP.s:1878   .text.ledStatus:0000000000000000 ledStatus
     /tmp/cc1kQXNP.s:1899   .text.ledStatus:000000000000000c $d
     /tmp/cc1kQXNP.s:1904   .text.led:0000000000000000 $t
     /tmp/cc1kQXNP.s:1911   .text.led:0000000000000000 led
     /tmp/cc1kQXNP.s:1960   .text.led:0000000000000038 $d
     /tmp/cc1kQXNP.s:2061   .data.parameters:0000000000000000 parameters
     /tmp/cc1kQXNP.s:1987   .bss.g_uptime:0000000000000000 g_uptime
     /tmp/cc1kQXNP.s:2048   .data.FlashAddress:0000000000000000 FlashAddress
     /tmp/cc1kQXNP.s:2014   .bss.rawcommandTransfer:0000000000000000 rawcommandTransfer
                            *COM*:0000000000000001 OutIndex
                            *COM*:0000000000000001 LedStatus
     /tmp/cc1kQXNP.s:2054   .data.nodeID:0000000000000000 nodeID
     /tmp/cc1kQXNP.s:2007   .bss.rawcommandTag:0000000000000000 rawcommandTag
     /tmp/cc1kQXNP.s:1977   .bss.g_canard:0000000000000000 $d
     /tmp/cc1kQXNP.s:1981   .bss.g_canard:0000000000000000 g_canard
     /tmp/cc1kQXNP.s:1984   .bss.g_uptime:0000000000000000 $d
     /tmp/cc1kQXNP.s:1990   .bss.led_time.8078:0000000000000000 $d
     /tmp/cc1kQXNP.s:1994   .bss.led_time.8078:0000000000000000 led_time.8078
     /tmp/cc1kQXNP.s:1997   .bss.publish_time.7999:0000000000000000 $d
     /tmp/cc1kQXNP.s:2001   .bss.publish_time.7999:0000000000000000 publish_time.7999
     /tmp/cc1kQXNP.s:2008   .bss.rawcommandTag:0000000000000000 $d
     /tmp/cc1kQXNP.s:2010   .bss.rawcommandTransfer:0000000000000000 $d
     /tmp/cc1kQXNP.s:2017   .bss.rxTag.8074:0000000000000000 $d
     /tmp/cc1kQXNP.s:2021   .bss.rxTag.8074:0000000000000000 rxTag.8074
     /tmp/cc1kQXNP.s:2024   .bss.signal_time.8075:0000000000000000 $d
     /tmp/cc1kQXNP.s:2028   .bss.signal_time.8075:0000000000000000 signal_time.8075
     /tmp/cc1kQXNP.s:2031   .bss.spin_time.7991:0000000000000000 $d
     /tmp/cc1kQXNP.s:2035   .bss.spin_time.7991:0000000000000000 spin_time.7991
     /tmp/cc1kQXNP.s:2041   .bss.transfer_id.7993:0000000000000000 transfer_id.7993
     /tmp/cc1kQXNP.s:2042   .bss.transfer_id.7993:0000000000000000 $d
     /tmp/cc1kQXNP.s:2044   .data.FlashAddress:0000000000000000 $d
     /tmp/cc1kQXNP.s:2057   .data.parameters:0000000000000000 $d
     /tmp/cc1kQXNP.s:2103   .rodata.__func__.5968:0000000000000000 $d
     /tmp/cc1kQXNP.s:2107   .rodata.__func__.5968:0000000000000000 __func__.5968
     /tmp/cc1kQXNP.s:2110   .rodata.getsetHandleCanard.str1.4:0000000000000000 $d
     /tmp/cc1kQXNP.s:2114   .rodata.makeNodeInfoMessage.str1.4:0000000000000000 $d
     /tmp/cc1kQXNP.s:2118   .rodata.signalTag.str1.4:0000000000000000 $d
     /tmp/cc1kQXNP.s:2125   .rodata.str1.4:0000000000000000 $d
     /tmp/cc1kQXNP.s:2138   .rodata.uavcanInit.str1.4:0000000000000000 $d

UNDEFINED SYMBOLS
canardPeekTxQueue
canardSTM32Transmit
canardPopTxQueue
HAL_GetTick
canardEncodeScalar
canardBroadcast
memset
canardRequestOrRespond
htim3
canardDecodeScalar
strlen
memcpy
StmFlashRead
StmFlashWrite
ARM GAS  /tmp/cc1kQXNP.s 			page 57


HAL_UART_Transmit
strncmp
huart1
HAL_RCC_GetPCLK1Freq
__assert_func
canardSTM32Init
canardInit
canardSetLocalNodeID
HAL_GPIO_WritePin
canardSTM32Receive
canardHandleRxFrame
HAL_GPIO_TogglePin
